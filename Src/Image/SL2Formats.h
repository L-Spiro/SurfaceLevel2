/**
 * Copyright L. Spiro 2024
 *
 * Written by: Shawn (L. Spiro) Wilcoxen
 *
 * Description: All of the image formats, along with conversion routines and functions for working with the formats (encoding, decoding, etc.)
 */

#pragma once

#include "../Thread/SL2Events.h"
#include "../Utilities/SL2Float16.h"
#include "../Utilities/SL2FloatX.h"
#include "../Utilities/SL2Utilities.h"
#include "Squish/squish.h"
#include <atomic>
#include <cstdint>
#include <thread>


/** 16-bit float metrics. */
#define SL2_FLOAT16																	5, 10, true, false

/** 11-bit float metrics. */
#define SL2_FLOAT11																	5, 6, false, false

/** 10-bit float metrics. */
#define SL2_FLOAT10																	5, 5, false, false

/** RGB9_E5 bias. */
#define SL2_RGB9E5_EXP_BIAS															15

/** RGB9_E5 mantissa bits. */
#define SL2_RGB9E5_MANTISSA_BITS													9

/** RGB9_E5 exponent bits. */
#define SL2_RGB9E5_EXPONENT_BITS													5

/** RGB9_E5 max valid exponent bias. */
#define SL2_RGB9E5_MAX_VALID_BIASED_EXP												31

/** RGB9_E5 max exponent. */
#define SL2_MAX_RGB9E5_EXP															(SL2_RGB9E5_MAX_VALID_BIASED_EXP - SL2_RGB9E5_EXP_BIAS)

/** RGB9_E5 mantissa values. */
#define SL2_RGB9E5_MANTISSA_VALUES													(1 << SL2_RGB9E5_MANTISSA_BITS)

/** RGB9_E5 max mantissa. */
#define SL2_MAX_RGB9E5_MANTISSA														(SL2_RGB9E5_MANTISSA_VALUES - 1)

/** RGB9_E5 max. */
#define SL2_MAX_RGB9E5																(static_cast<double>(SL2_MAX_RGB9E5_MANTISSA) / SL2_RGB9E5_MANTISSA_VALUES * (1 << SL2_MAX_RGB9E5_EXP))

/** RGB9_E5 epsilon. */
#define SL2_EPSILON_RGB9E5															((1.0 / SL2_RGB9E5_MANTISSA_VALUES) / (1 << SL2_RGB9E5_EXP_BIAS))

/** How many rows to do per-thread during a DXT conversion. */
#define SL2_DXT_ROWS																12

/** How many rows to do per-thread for BC6H and BC7 conversions. */
#define SL2_BC_ROWS																	24

/** Maximum number of threads to run concurrently for BC conversions. */
#define SL2_BC_MAX_THREADS															16

/** Makes a texture-compression flag. */
#define SL2_MAKE_COMP_FLAG( VAL )													uint32_t( VAL ) << 8

/** Gets a texture-compression flag. */
#define SL2_GET_COMP_FLAG( VAL )													(((VAL) >> 8) & 0xF)


#pragma warning( push )

// warning C4293: '>>' : shift count negative or too big, undefined behavior
//#pragma warning( disable : 4293 )

namespace sl2 {

	// == Enumerations.
	// == Enumerations.
	/** Errors. */
	enum SL2_ERRORS : int16_t {
		SL2_E_SUCCESS																= 0,							/**< No problem. */
		SL2_E_OUTOFMEMORY															= -1,							/**< Out of memory. */
		SL2_E_FILENOTFOUND															= -2,							/**< File was not found at the given path. */
		SL2_E_INVALIDWRITEPERMISSIONS												= -3,							/**< Unable to write to a file. */
		SL2_E_NODISKSPACE															= -4,							/**< Unable to write to a file (disk space). */
		SL2_E_INVALIDFILETYPE														= -5,							/**< File exists but is not in the expected format. */
		SL2_E_INVALIDCALL															= -6,							/**< Invalid call. */
		SL2_E_INVALIDDATA															= -7,							/**< Invalid input data. */
		SL2_E_INTERNALERROR															= -8,							/**< Internal error. */
		SL2_E_FEATURENOTSUPPORTED													= -9,							/**< Feature not yet supported. */
		SL2_E_PARTIALFAILURE														= -10,							/**< Within multiple tasks, one or more failed. */
		SL2_E_BADVERSION															= -11,							/**< Unsupported version (of a file etc.) */
		SL2_E_FILEOVERFLOW															= -12,							/**< The file exceeded the maximum size supported by the system. */
		SL2_E_FILEWRITEERROR														= -13,							/**< An error occurred while writing the file. */
		SL2_E_BADFORMAT																= -14,							/**< Bad data format. */
	};

	/**
	 * glType values.  Table 8.2 of OpenGL 4.4.
	 */
	enum SL2_KTX_TYPE : uint16_t {
		SL2_KT_GL_INVALID															= 0,
		SL2_KT_GL_BYTE																= 0x1400, /** GL_BYTE */
		SL2_KT_GL_UNSIGNED_BYTE														= 0x1401, /** GL_UNSIGNED_BYTE */
		SL2_KT_GL_SHORT																= 0x1402, /** GL_SHORT */
		SL2_KT_GL_UNSIGNED_SHORT													= 0x1403, /** GL_UNSIGNED_SHORT */
		SL2_KT_GL_INT																= 0x1404, /** GL_INT */
		SL2_KT_GL_UNSIGNED_INT														= 0x1405, /** GL_UNSIGNED_INT */
		SL2_KT_GL_INT64																= 0x140E, /** GL_INT64 */
		SL2_KT_GL_UNSIGNED_INT64													= 0x140F, /** GL_UNSIGNED_INT64 */
		SL2_KT_GL_HALF_FLOAT														= 0x140B, /** GL_HALF_FLOAT */
		SL2_KT_GL_HALF_FLOAT_OES													= 0x8D61, /** GL_HALF_FLOAT_OES */
		SL2_KT_GL_FLOAT																= 0x1406, /** GL_FLOAT */
		SL2_KT_GL_DOUBLE															= 0x140A, /** GL_DOUBLE */
		SL2_KT_GL_UNSIGNED_BYTE_3_3_2												= 0x8032, /** GL_UNSIGNED_BYTE_3_3_2 */
		SL2_KT_GL_UNSIGNED_BYTE_2_3_3_REV											= 0x8362, /** GL_UNSIGNED_BYTE_2_3_3_REV */
		SL2_KT_GL_UNSIGNED_SHORT_5_6_5												= 0x8363, /** GL_UNSIGNED_SHORT_5_6_5 */
		SL2_KT_GL_UNSIGNED_SHORT_5_6_5_REV											= 0x8364, /** GL_UNSIGNED_SHORT_5_6_5_REV */
		SL2_KT_GL_UNSIGNED_SHORT_4_4_4_4											= 0x8033, /** GL_UNSIGNED_SHORT_4_4_4_4 */
		SL2_KT_GL_UNSIGNED_SHORT_4_4_4_4_REV										= 0x8365, /** GL_UNSIGNED_SHORT_4_4_4_4_REV */
		SL2_KT_GL_UNSIGNED_SHORT_5_5_5_1											= 0x8034, /** GL_UNSIGNED_SHORT_5_5_5_1 */
		SL2_KT_GL_UNSIGNED_SHORT_1_5_5_5_REV										= 0x8366, /** GL_UNSIGNED_SHORT_1_5_5_5_REV */
		SL2_KT_GL_UNSIGNED_INT_8_8_8_8												= 0x8035, /** GL_UNSIGNED_INT_8_8_8_8 */
		SL2_KT_GL_UNSIGNED_INT_8_8_8_8_REV											= 0x8367, /** GL_UNSIGNED_INT_8_8_8_8_REV */
		SL2_KT_GL_UNSIGNED_INT_10_10_10_2											= 0x8036, /** GL_UNSIGNED_INT_10_10_10_2 */
		SL2_KT_GL_UNSIGNED_INT_2_10_10_10_REV										= 0x8368, /** GL_UNSIGNED_INT_2_10_10_10_REV */
		SL2_KT_GL_UNSIGNED_INT_10F_11F_11F_REV										= 0x8C3B, /** GL_UNSIGNED_INT_10F_11F_11F_REV */
		SL2_KT_GL_UNSIGNED_INT_5_9_9_9_REV											= 0x8C3E, /** GL_UNSIGNED_INT_5_9_9_9_REV */
		SL2_KT_GL_UNSIGNED_INT_24_8													= 0x84FA, /** GL_UNSIGNED_INT_24_8 */
		SL2_KT_GL_FLOAT_32_UNSIGNED_INT_24_8_REV									= 0x8DAD, /** GL_FLOAT_32_UNSIGNED_INT_24_8_REV */
		SL2_KT_0																	= 0,
	};

	/**
	 * glFormat values.  Table 8.3 of OpenGL 4.4.
	 */
	enum SL2_KTX_FORMAT : uint16_t {
		SL2_KF_GL_INVALID															= 0,
		SL2_KF_GL_RED																= 0x1903, /** GL_RED */
		SL2_KF_GL_GREEN																= 0x1904, /** GL_GREEN */
		SL2_KF_GL_BLUE																= 0x1905, /** GL_BLUE */
		SL2_KF_GL_ALPHA																= 0x1906, /** GL_ALPHA */
		SL2_KF_GL_LUMINANCE															= 0x1909, /** GL_LUMINANCE */
		SL2_KF_GL_SLUMINANCE														= 0x8C46, /** GL_SLUMINANCE */
		SL2_KF_GL_LUMINANCE_ALPHA													= 0x190A, /** GL_LUMINANCE_ALPHA */
		SL2_KF_GL_SLUMINANCE_ALPHA													= 0x8C44, /** GL_SLUMINANCE_ALPHA */
		SL2_KF_GL_INTENSITY															= 0x8049, /** GL_INTENSITY */
		SL2_KF_GL_RG																= 0x8227, /** GL_RG */
		SL2_KF_GL_RGB																= 0x1907, /** GL_RGB */
		SL2_KF_GL_BGR																= 0x80E0, /** GL_BGR */
		SL2_KF_GL_RGBA																= 0x1908, /** GL_RGBA */
		SL2_KF_GL_BGRA																= 0x80E1, /** GL_BGRA */
		SL2_KF_GL_RED_INTEGER														= 0x8D94, /** GL_RED_INTEGER */
		SL2_KF_GL_GREEN_INTEGER														= 0x8D95, /** GL_GREEN_INTEGER */
		SL2_KF_GL_BLUE_INTEGER														= 0x8D96, /** GL_BLUE_INTEGER */
		SL2_KF_GL_ALPHA_INTEGER														= 0x8D97, /** GL_ALPHA_INTEGER */
		SL2_KF_GL_LUMINANCE_INTEGER													= 0x8D9C, /** GL_LUMINANCE_INTEGER */
		SL2_KF_GL_LUMINANCE_ALPHA_INTEGER											= 0x8D9D, /** GL_LUMINANCE_ALPHA_INTEGER */
		SL2_KF_GL_RG_INTEGER														= 0x8228, /** GL_RG_INTEGER */
		SL2_KF_GL_RGB_INTEGER														= 0x8D98, /** GL_RGB_INTEGER */
		SL2_KF_GL_BGR_INTEGER														= 0x8D9A, /** GL_BGR_INTEGER */
		SL2_KF_GL_RGBA_INTEGER														= 0x8D99, /** GL_RGBA_INTEGER */
		SL2_KF_GL_BGRA_INTEGER														= 0x8D9B, /** GL_BGRA_INTEGER */
		SL2_KF_GL_COLOR_INDEX														= 0x1900, /** GL_COLOR_INDEX */
		SL2_KF_GL_STENCIL_INDEX														= 0x1901, /** GL_STENCIL_INDEX */
		SL2_KF_GL_DEPTH_COMPONENT													= 0x1902, /** GL_DEPTH_COMPONENT */
		SL2_KF_GL_DEPTH_STENCIL														= 0x84F9, /** GL_DEPTH_STENCIL */
	};

	/**
	 * glInternalFormat values.  Tables 8.12, 8.13, and 8.14 of OpenGL 4.4.
	 */
	enum SL2_KTX_INTERNAL_FORMAT : uint16_t {
		SL2_KIF_GL_INVALID															= 0,
		//
		// 8 bits per component
		//
		SL2_KIF_GL_R8																= 0x8229, /** GL_R8 */
		SL2_KIF_GL_RG8																= 0x822B, /** GL_RG8 */
		SL2_KIF_GL_RGB8																= 0x8051, /** GL_RGB8 */
		SL2_KIF_GL_RGBA8															= 0x8058, /** GL_RGBA8 */
		SL2_KIF_GL_R8_SNORM															= 0x8F94, /** GL_R8_SNORM */
		SL2_KIF_GL_RG8_SNORM														= 0x8F95, /** GL_RG8_SNORM */
		SL2_KIF_GL_RGB8_SNORM														= 0x8F96, /** GL_RGB8_SNORM */
		SL2_KIF_GL_RGBA8_SNORM														= 0x8F97, /** GL_RGBA8_SNORM */
		SL2_KIF_GL_R8UI																= 0x8232, /** GL_R8UI */
		SL2_KIF_GL_RG8UI															= 0x8238, /** GL_RG8UI */
		SL2_KIF_GL_RGB8UI															= 0x8D7D, /** GL_RGB8UI */
		SL2_KIF_GL_RGBA8UI															= 0x8D7C, /** GL_RGBA8UI */
		SL2_KIF_GL_R8I																= 0x8231, /** GL_R8I */
		SL2_KIF_GL_RG8I																= 0x8237, /** GL_RG8I */
		SL2_KIF_GL_RGB8I															= 0x8D8F, /** GL_RGB8I */
		SL2_KIF_GL_RGBA8I															= 0x8D8E, /** GL_RGBA8I */
		SL2_KIF_GL_SR8																= 0x8FBD, /** GL_SR8 */
		SL2_KIF_GL_SRG8																= 0x8FBE, /** GL_SRG8 */
		SL2_KIF_GL_SRGB8															= 0x8C41, /** GL_SRGB8 */
		SL2_KIF_GL_SRGB8_ALPHA8														= 0x8C43, /** GL_SRGB8_ALPHA8 */
		//
		// 16 bits per component
		//
		SL2_KIF_GL_R16																= 0x822A, /** GL_R16 */
		SL2_KIF_GL_RG16																= 0x822C, /** GL_RG16 */
		SL2_KIF_GL_RGB16															= 0x8054, /** GL_RGB16 */
		SL2_KIF_GL_RGBA16															= 0x805B, /** GL_RGBA16 */
		SL2_KIF_GL_R16_SNORM														= 0x8F98, /** GL_R16_SNORM */
		SL2_KIF_GL_RG16_SNORM														= 0x8F99, /** GL_RG16_SNORM */
		SL2_KIF_GL_RGB16_SNORM														= 0x8F9A, /** GL_RGB16_SNORM */
		SL2_KIF_GL_RGBA16_SNORM														= 0x8F9B, /** GL_RGBA16_SNORM */
		SL2_KIF_GL_R16UI															= 0x8234, /** GL_R16UI */
		SL2_KIF_GL_RG16UI															= 0x823A, /** GL_RG16UI */
		SL2_KIF_GL_RGB16UI															= 0x8D77, /** GL_RGB16UI */
		SL2_KIF_GL_RGBA16UI															= 0x8D76, /** GL_RGBA16UI */
		SL2_KIF_GL_R16I																= 0x8233, /** GL_R16I */
		SL2_KIF_GL_RG16I															= 0x8239, /** GL_RG16I */
		SL2_KIF_GL_RGB16I															= 0x8D89, /** GL_RGB16I */
		SL2_KIF_GL_RGBA16I															= 0x8D88, /** GL_RGBA16I */
		SL2_KIF_GL_R16F																= 0x822D, /** GL_R16F */
		SL2_KIF_GL_RG16F															= 0x822F, /** GL_RG16F */
		SL2_KIF_GL_RGB16F															= 0x881B, /** GL_RGB16F */
		SL2_KIF_GL_RGBA16F															= 0x881A, /** GL_RGBA16F */
		//
		// 32 bits per component
		//
		SL2_KIF_GL_R32UI															= 0x8236, /** GL_R32UI */
		SL2_KIF_GL_RG32UI															= 0x823C, /** GL_RG32UI */
		SL2_KIF_GL_RGB32UI															= 0x8D71, /** GL_RGB32UI */
		SL2_KIF_GL_RGBA32UI															= 0x8D70, /** GL_RGBA32UI */
		SL2_KIF_GL_R32I																= 0x8235, /** GL_R32I */
		SL2_KIF_GL_RG32I															= 0x823B, /** GL_RG32I */
		SL2_KIF_GL_RGB32I															= 0x8D83, /** GL_RGB32I */
		SL2_KIF_GL_RGBA32I															= 0x8D82, /** GL_RGBA32I */
		SL2_KIF_GL_R32F																= 0x822E, /** GL_R32F */
		SL2_KIF_GL_RG32F															= 0x8230, /** GL_RG32F */
		SL2_KIF_GL_RGB32F															= 0x8815, /** GL_RGB32F */
		SL2_KIF_GL_RGBA32F															= 0x8814, /** GL_RGBA32F */
		//
		// Packed
		//
		SL2_KIF_GL_R3_G3_B2															= 0x2A10, /** GL_R3_G3_B2 */
		SL2_KIF_GL_RGB4																= 0x804F, /** GL_RGB4 */
		SL2_KIF_GL_RGB5																= 0x8050, /** GL_RGB5 */
		SL2_KIF_GL_RGB565															= 0x8D62, /** GL_RGB565 */
		SL2_KIF_GL_RGB10															= 0x8052, /** GL_RGB10 */
		SL2_KIF_GL_RGB12															= 0x8053, /** GL_RGB12 */
		SL2_KIF_GL_RGBA2															= 0x8055, /** GL_RGBA2 */
		SL2_KIF_GL_RGBA4															= 0x8056, /** GL_RGBA4 */
		SL2_KIF_GL_RGBA12															= 0x805A, /** GL_RGBA12 */
		SL2_KIF_GL_RGB5_A1															= 0x8057, /** GL_RGB5_A1 */
		SL2_KIF_GL_RGB10_A2															= 0x8059, /** GL_RGB10_A2 */
		SL2_KIF_GL_RGB10_A2UI														= 0x906F, /** GL_RGB10_A2UI */
		SL2_KIF_GL_R11F_G11F_B10F													= 0x8C3A, /** GL_R11F_G11F_B10F */
		SL2_KIF_GL_RGB9_E5															= 0x8C3D, /** GL_RGB9_E5 */
		//
		// Alpha
		//
		SL2_KIF_GL_ALPHA4															= 0x803B, /** GL_ALPHA4 */
		SL2_KIF_GL_ALPHA8															= 0x803C, /** GL_ALPHA8 */
		SL2_KIF_GL_ALPHA8_SNORM														= 0x9014, /** GL_ALPHA8_SNORM */
		SL2_KIF_GL_ALPHA8UI_EXT														= 0x8D7E, /** GL_ALPHA8UI_EXT */
		SL2_KIF_GL_ALPHA8I_EXT														= 0x8D90, /** GL_ALPHA8I_EXT */
		SL2_KIF_GL_ALPHA12															= 0x803D, /** GL_ALPHA12 */
		SL2_KIF_GL_ALPHA16															= 0x803E, /** GL_ALPHA16 */
		SL2_KIF_GL_ALPHA16_SNORM													= 0x9018, /** GL_ALPHA16_SNORM */
		SL2_KIF_GL_ALPHA16UI_EXT													= 0x8D78, /** GL_ALPHA16UI_EXT */
		SL2_KIF_GL_ALPHA16I_EXT														= 0x8D8A, /** GL_ALPHA16I_EXT */
		SL2_KIF_GL_ALPHA16F_ARB														= 0x881C, /** GL_ALPHA16F_ARB */
		SL2_KIF_GL_ALPHA32UI_EXT													= 0x8D72, /** GL_ALPHA32UI_EXT */
		SL2_KIF_GL_ALPHA32I_EXT														= 0x8D84, /** GL_ALPHA32I_EXT */
		SL2_KIF_GL_ALPHA32F_ARB														= 0x8816, /** GL_ALPHA32F_ARB */
		//
		// Luminance
		//
		SL2_KIF_GL_LUMINANCE4														= 0x803F, /** GL_LUMINANCE4 */
		SL2_KIF_GL_LUMINANCE8														= 0x8040, /** GL_LUMINANCE8 */
		SL2_KIF_GL_LUMINANCE8_SNORM													= 0x9015, /** GL_LUMINANCE8_SNORM */
		SL2_KIF_GL_SLUMINANCE8														= 0x8C47, /** GL_SLUMINANCE8 */
		SL2_KIF_GL_LUMINANCE8UI_EXT													= 0x8D80, /** GL_LUMINANCE8UI_EXT */
		SL2_KIF_GL_LUMINANCE8I_EXT													= 0x8D92, /** GL_LUMINANCE8I_EXT */
		SL2_KIF_GL_LUMINANCE12														= 0x8041, /** GL_LUMINANCE12 */
		SL2_KIF_GL_LUMINANCE16														= 0x8042, /** GL_LUMINANCE16 */
		SL2_KIF_GL_LUMINANCE16_SNORM												= 0x9019, /** GL_LUMINANCE16_SNORM */
		SL2_KIF_GL_LUMINANCE16UI_EXT												= 0x8D7A, /** GL_LUMINANCE16UI_EXT */
		SL2_KIF_GL_LUMINANCE16I_EXT													= 0x8D8C, /** GL_LUMINANCE16I_EXT */
		SL2_KIF_GL_LUMINANCE16F_ARB													= 0x881E, /** GL_LUMINANCE16F_ARB */
		SL2_KIF_GL_LUMINANCE32UI_EXT												= 0x8D74, /** GL_LUMINANCE32UI_EXT */
		SL2_KIF_GL_LUMINANCE32I_EXT													= 0x8D86, /** GL_LUMINANCE32I_EXT */
		SL2_KIF_GL_LUMINANCE32F_ARB													= 0x8818, /** GL_LUMINANCE32F_ARB */
		//
		// Luminance/Alpha
		//
		SL2_KIF_GL_LUMINANCE4_ALPHA4												= 0x8043, /** GL_LUMINANCE4_ALPHA4 */
		SL2_KIF_GL_LUMINANCE6_ALPHA2												= 0x8044, /** GL_LUMINANCE6_ALPHA2 */
		SL2_KIF_GL_LUMINANCE8_ALPHA8												= 0x8045, /** GL_LUMINANCE8_ALPHA8 */
		SL2_KIF_GL_LUMINANCE8_ALPHA8_SNORM											= 0x9016, /** GL_LUMINANCE8_ALPHA8_SNORM */
		SL2_KIF_GL_SLUMINANCE8_ALPHA8												= 0x8C45, /** GL_SLUMINANCE8_ALPHA8 */
		SL2_KIF_GL_LUMINANCE_ALPHA8UI_EXT											= 0x8D81, /** GL_LUMINANCE_ALPHA8UI_EXT */
		SL2_KIF_GL_LUMINANCE_ALPHA8I_EXT											= 0x8D93, /** GL_LUMINANCE_ALPHA8I_EXT */
		SL2_KIF_GL_LUMINANCE12_ALPHA4												= 0x8046, /** GL_LUMINANCE12_ALPHA4 */
		SL2_KIF_GL_LUMINANCE12_ALPHA12												= 0x8047, /** GL_LUMINANCE12_ALPHA12 */
		SL2_KIF_GL_LUMINANCE16_ALPHA16												= 0x8048, /** GL_LUMINANCE16_ALPHA16 */
		SL2_KIF_GL_LUMINANCE16_ALPHA16_SNORM										= 0x901A, /** GL_LUMINANCE16_ALPHA16_SNORM */
		SL2_KIF_GL_LUMINANCE_ALPHA16UI_EXT											= 0x8D7B, /** GL_LUMINANCE_ALPHA16UI_EXT */
		SL2_KIF_GL_LUMINANCE_ALPHA16I_EXT											= 0x8D8D, /** GL_LUMINANCE_ALPHA16I_EXT */
		SL2_KIF_GL_LUMINANCE_ALPHA16F_ARB											= 0x881F, /** GL_LUMINANCE_ALPHA16F_ARB */
		SL2_KIF_GL_LUMINANCE_ALPHA32UI_EXT											= 0x8D75, /** GL_LUMINANCE_ALPHA32UI_EXT */
		SL2_KIF_GL_LUMINANCE_ALPHA32I_EXT											= 0x8D87, /** GL_LUMINANCE_ALPHA32I_EXT */
		SL2_KIF_GL_LUMINANCE_ALPHA32F_ARB											= 0x8819, /** GL_LUMINANCE_ALPHA32F_ARB */
		//
		// Intensity
		//
		SL2_KIF_GL_INTENSITY4														= 0x804A, /** GL_INTENSITY4 */
		SL2_KIF_GL_INTENSITY8														= 0x804B, /** GL_INTENSITY8 */
		SL2_KIF_GL_INTENSITY8_SNORM													= 0x9017, /** GL_INTENSITY8_SNORM */
		SL2_KIF_GL_INTENSITY8UI_EXT													= 0x8D7F, /** GL_INTENSITY8UI_EXT */
		SL2_KIF_GL_INTENSITY8I_EXT													= 0x8D91, /** GL_INTENSITY8I_EXT */
		SL2_KIF_GL_INTENSITY12														= 0x804C, /** GL_INTENSITY12 */
		SL2_KIF_GL_INTENSITY16														= 0x804D, /** GL_INTENSITY16 */
		SL2_KIF_GL_INTENSITY16_SNORM												= 0x901B, /** GL_INTENSITY16_SNORM */
		SL2_KIF_GL_INTENSITY16UI_EXT												= 0x8D79, /** GL_INTENSITY16UI_EXT */
		SL2_KIF_GL_INTENSITY16I_EXT													= 0x8D8B, /** GL_INTENSITY16I_EXT */
		SL2_KIF_GL_INTENSITY16F_ARB													= 0x881D, /** GL_INTENSITY16F_ARB */
		SL2_KIF_GL_INTENSITY32UI_EXT												= 0x8D73, /** GL_INTENSITY32UI_EXT */
		SL2_KIF_GL_INTENSITY32I_EXT													= 0x8D85, /** GL_INTENSITY32I_EXT */
		SL2_KIF_GL_INTENSITY32F_ARB													= 0x8817, /** GL_INTENSITY32F_ARB */
		//
		// Generic compression
		//
		SL2_KIF_GL_COMPRESSED_RED													= 0x8225, /** GL_COMPRESSED_RED */
		SL2_KIF_GL_COMPRESSED_ALPHA													= 0x84E9, /** GL_COMPRESSED_ALPHA */
		SL2_KIF_GL_COMPRESSED_LUMINANCE												= 0x84EA, /** GL_COMPRESSED_LUMINANCE */
		SL2_KIF_GL_COMPRESSED_SLUMINANCE											= 0x8C4A, /** GL_COMPRESSED_SLUMINANCE */
		SL2_KIF_GL_COMPRESSED_LUMINANCE_ALPHA										= 0x84EB, /** GL_COMPRESSED_LUMINANCE_ALPHA */
		SL2_KIF_GL_COMPRESSED_SLUMINANCE_ALPHA										= 0x8C4B, /** GL_COMPRESSED_SLUMINANCE_ALPHA */
		SL2_KIF_GL_COMPRESSED_INTENSITY												= 0x84EC, /** GL_COMPRESSED_INTENSITY */
		SL2_KIF_GL_COMPRESSED_RG													= 0x8226, /** GL_COMPRESSED_RG */
		SL2_KIF_GL_COMPRESSED_RGB													= 0x84ED, /** GL_COMPRESSED_RGB */
		SL2_KIF_GL_COMPRESSED_RGBA													= 0x84EE, /** GL_COMPRESSED_RGBA */
		SL2_KIF_GL_COMPRESSED_SRGB													= 0x8C48, /** GL_COMPRESSED_SRGB */
		SL2_KIF_GL_COMPRESSED_SRGB_ALPHA											= 0x8C49, /** GL_COMPRESSED_SRGB_ALPHA */
		//
		// FXT1
		//
		SL2_KIF_GL_COMPRESSED_RGB_FXT1_3DFX											= 0x86B0, /** GL_COMPRESSED_RGB_FXT1_3DFX */
		SL2_KIF_GL_COMPRESSED_RGBA_FXT1_3DFX										= 0x86B1, /** GL_COMPRESSED_RGBA_FXT1_3DFX */
		//
		// S3TC/DXT/BC
		//
		SL2_KIF_GL_COMPRESSED_RGB_S3TC_DXT1_EXT										= 0x83F0, /** GL_COMPRESSED_RGB_S3TC_DXT1_EXT */
		SL2_KIF_GL_COMPRESSED_RGBA_S3TC_DXT1_EXT									= 0x83F1, /** GL_COMPRESSED_RGBA_S3TC_DXT1_EXT */
		SL2_KIF_GL_COMPRESSED_RGBA_S3TC_DXT3_EXT									= 0x83F2, /** GL_COMPRESSED_RGBA_S3TC_DXT3_EXT */
		SL2_KIF_GL_COMPRESSED_RGBA_S3TC_DXT5_EXT									= 0x83F3, /** GL_COMPRESSED_RGBA_S3TC_DXT5_EXT */
		SL2_KIF_GL_COMPRESSED_SRGB_S3TC_DXT1_EXT									= 0x8C4C, /** GL_COMPRESSED_SRGB_S3TC_DXT1_EXT */
		SL2_KIF_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT								= 0x8C4D, /** GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */
		SL2_KIF_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT								= 0x8C4E, /** GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */
		SL2_KIF_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT								= 0x8C4F, /** GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */
		SL2_KIF_GL_COMPRESSED_LUMINANCE_LATC1_EXT									= 0x8C70, /** GL_COMPRESSED_LUMINANCE_LATC1_EXT */
		SL2_KIF_GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT								= 0x8C72, /** GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT */
		SL2_KIF_GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT							= 0x8C71, /** GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT */
		SL2_KIF_GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT						= 0x8C73, /** GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT */
		SL2_KIF_GL_COMPRESSED_RED_RGTC1												= 0x8DBB, /** GL_COMPRESSED_RED_RGTC1 */
		SL2_KIF_GL_COMPRESSED_RG_RGTC2												= 0x8DBD, /** GL_COMPRESSED_RG_RGTC2 */
		SL2_KIF_GL_COMPRESSED_SIGNED_RED_RGTC1										= 0x8DBC, /** GL_COMPRESSED_SIGNED_RED_RGTC1 */
		SL2_KIF_GL_COMPRESSED_SIGNED_RG_RGTC2										= 0x8DBE, /** GL_COMPRESSED_SIGNED_RG_RGTC2 */
		SL2_KIF_GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT									= 0x8E8E, /** GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT */
		SL2_KIF_GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT								= 0x8E8F, /** GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT */
		SL2_KIF_GL_COMPRESSED_RGBA_BPTC_UNORM										= 0x8E8C, /** GL_COMPRESSED_RGBA_BPTC_UNORM */
		SL2_KIF_GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM									= 0x8E8D, /** GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM */
		//
		// ETC
		//
		SL2_KIF_GL_ETC1_RGB8_OES													= 0x8D64, /** GL_ETC1_RGB8_OES */
		SL2_KIF_GL_COMPRESSED_RGB8_ETC2												= 0x9274, /** GL_COMPRESSED_RGB8_ETC2 */
		SL2_KIF_GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2							= 0x9276, /** GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
		SL2_KIF_GL_COMPRESSED_RGBA8_ETC2_EAC										= 0x9278, /** GL_COMPRESSED_RGBA8_ETC2_EAC */
		SL2_KIF_GL_COMPRESSED_SRGB8_ETC2											= 0x9275, /** GL_COMPRESSED_SRGB8_ETC2 */
		SL2_KIF_GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2						= 0x9277, /** GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC									= 0x9279, /** GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */
		SL2_KIF_GL_COMPRESSED_R11_EAC												= 0x9270, /** GL_COMPRESSED_R11_EAC */
		SL2_KIF_GL_COMPRESSED_RG11_EAC												= 0x9272, /** GL_COMPRESSED_RG11_EAC */
		SL2_KIF_GL_COMPRESSED_SIGNED_R11_EAC										= 0x9271, /** GL_COMPRESSED_SIGNED_R11_EAC */
		SL2_KIF_GL_COMPRESSED_SIGNED_RG11_EAC										= 0x9273, /** GL_COMPRESSED_SIGNED_RG11_EAC */
		//
		// PVRTC
		//
		SL2_KIF_GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG									= 0x8C01, /** GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG */
		SL2_KIF_GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG									= 0x8C00, /** GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG */
		SL2_KIF_GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG									= 0x8C03, /** GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG */
		SL2_KIF_GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG									= 0x8C02, /** GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG */

		SL2_KIF_GL_COMPRESSED_RGBA_PVRTC_2BPPV2_IMG									= 0x9137, /** GL_COMPRESSED_RGBA_PVRTC_2BPPV2_IMG */
		SL2_KIF_GL_COMPRESSED_RGBA_PVRTC_4BPPV2_IMG									= 0x9138, /** GL_COMPRESSED_RGBA_PVRTC_4BPPV2_IMG */

		SL2_KIF_GL_COMPRESSED_SRGB_PVRTC_2BPPV1_EXT									= 0x8A54, /** GL_COMPRESSED_SRGB_PVRTC_2BPPV1_EXT */
		SL2_KIF_GL_COMPRESSED_SRGB_PVRTC_4BPPV1_EXT									= 0x8A55, /** GL_COMPRESSED_SRGB_PVRTC_4BPPV1_EXT */
		SL2_KIF_GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT							= 0x8A56, /** GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT */
		SL2_KIF_GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT							= 0x8A57, /** GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT */

		SL2_KIF_GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV2_IMG							= 0x93F0, /** GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV2_IMG */
		SL2_KIF_GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV2_IMG							= 0x93F1, /** GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV2_IMG */
		//
		// ASTC
		//
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_4x4_KHR										= 0x93B0, /** GL_COMPRESSED_RGBA_ASTC_4x4_KHR */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_5x4_KHR										= 0x93B1, /** GL_COMPRESSED_RGBA_ASTC_5x4_KHR */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_5x5_KHR										= 0x93B2, /** GL_COMPRESSED_RGBA_ASTC_5x5_KHR */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_6x5_KHR										= 0x93B3, /** GL_COMPRESSED_RGBA_ASTC_6x5_KHR */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_6x6_KHR										= 0x93B4, /** GL_COMPRESSED_RGBA_ASTC_6x6_KHR */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_8x5_KHR										= 0x93B5, /** GL_COMPRESSED_RGBA_ASTC_8x5_KHR */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_8x6_KHR										= 0x93B6, /** GL_COMPRESSED_RGBA_ASTC_8x6_KHR */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_8x8_KHR										= 0x93B7, /** GL_COMPRESSED_RGBA_ASTC_8x8_KHR */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_10x5_KHR									= 0x93B8, /** GL_COMPRESSED_RGBA_ASTC_10x5_KHR */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_10x6_KHR									= 0x93B9, /** GL_COMPRESSED_RGBA_ASTC_10x6_KHR */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_10x8_KHR									= 0x93BA, /** GL_COMPRESSED_RGBA_ASTC_10x8_KHR */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_10x10_KHR									= 0x93BB, /** GL_COMPRESSED_RGBA_ASTC_10x10_KHR */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_12x10_KHR									= 0x93BC, /** GL_COMPRESSED_RGBA_ASTC_12x10_KHR */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_12x12_KHR									= 0x93BD, /** GL_COMPRESSED_RGBA_ASTC_12x12_KHR */

		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR								= 0x93D0, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR								= 0x93D1, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR								= 0x93D2, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR								= 0x93D3, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR								= 0x93D4, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR								= 0x93D5, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR								= 0x93D6, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR								= 0x93D7, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR							= 0x93D8, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR							= 0x93D9, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR							= 0x93DA, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR							= 0x93DB, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR							= 0x93DC, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR							= 0x93DD, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR */

		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_3x3x3_OES									= 0x93C0, /** GL_COMPRESSED_RGBA_ASTC_3x3x3_OES */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_4x3x3_OES									= 0x93C1, /** GL_COMPRESSED_RGBA_ASTC_4x3x3_OES */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_4x4x3_OES									= 0x93C2, /** GL_COMPRESSED_RGBA_ASTC_4x4x3_OES */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_4x4x4_OES									= 0x93C3, /** GL_COMPRESSED_RGBA_ASTC_4x4x4_OES */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_5x4x4_OES									= 0x93C4, /** GL_COMPRESSED_RGBA_ASTC_5x4x4_OES */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_5x5x4_OES									= 0x93C5, /** GL_COMPRESSED_RGBA_ASTC_5x5x4_OES */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_5x5x5_OES									= 0x93C6, /** GL_COMPRESSED_RGBA_ASTC_5x5x5_OES */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_6x5x5_OES									= 0x93C7, /** GL_COMPRESSED_RGBA_ASTC_6x5x5_OES */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_6x6x5_OES									= 0x93C8, /** GL_COMPRESSED_RGBA_ASTC_6x6x5_OES */
		SL2_KIF_GL_COMPRESSED_RGBA_ASTC_6x6x6_OES									= 0x93C9, /** GL_COMPRESSED_RGBA_ASTC_6x6x6_OES */

		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES							= 0x93E0, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES							= 0x93E1, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES							= 0x93E2, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES							= 0x93E3, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES							= 0x93E4, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES							= 0x93E5, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES							= 0x93E6, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES							= 0x93E7, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES							= 0x93E8, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES */
		SL2_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES							= 0x93E9, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES */
		//
		// ATC
		//
		SL2_KIF_GL_ATC_RGB_AMD														= 0x8C92, /** GL_ATC_RGB_AMD */
		SL2_KIF_GL_ATC_RGBA_EXPLICIT_ALPHA_AMD										= 0x8C93, /** GL_ATC_RGBA_EXPLICIT_ALPHA_AMD */
		SL2_KIF_GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD									= 0x87EE, /** GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD */
		//
		// Palletized (combined palette)
		//
		SL2_KIF_GL_PALETTE4_RGB8_OES												= 0x8B90, /** GL_PALETTE4_RGB8_OES */
		SL2_KIF_GL_PALETTE4_RGBA8_OES												= 0x8B91, /** GL_PALETTE4_RGBA8_OES */
		SL2_KIF_GL_PALETTE4_R5_G6_B5_OES											= 0x8B92, /** GL_PALETTE4_R5_G6_B5_OES */
		SL2_KIF_GL_PALETTE4_RGBA4_OES												= 0x8B93, /** GL_PALETTE4_RGBA4_OES */
		SL2_KIF_GL_PALETTE4_RGB5_A1_OES												= 0x8B94, /** GL_PALETTE4_RGB5_A1_OES */
		SL2_KIF_GL_PALETTE8_RGB8_OES												= 0x8B95, /** GL_PALETTE8_RGB8_OES */
		SL2_KIF_GL_PALETTE8_RGBA8_OES												= 0x8B96, /** GL_PALETTE8_RGBA8_OES */
		SL2_KIF_GL_PALETTE8_R5_G6_B5_OES											= 0x8B97, /** GL_PALETTE8_R5_G6_B5_OES */
		SL2_KIF_GL_PALETTE8_RGBA4_OES												= 0x8B98, /** GL_PALETTE8_RGBA4_OES */
		SL2_KIF_GL_PALETTE8_RGB5_A1_OES												= 0x8B99, /** GL_PALETTE8_RGB5_A1_OES */
		//
		// Palletized (separate palette)
		//
		SL2_KIF_GL_COLOR_INDEX1_EXT													= 0x80E2, /** GL_COLOR_INDEX1_EXT */
		SL2_KIF_GL_COLOR_INDEX2_EXT													= 0x80E3, /** GL_COLOR_INDEX2_EXT */
		SL2_KIF_GL_COLOR_INDEX4_EXT													= 0x80E4, /** GL_COLOR_INDEX4_EXT */
		SL2_KIF_GL_COLOR_INDEX8_EXT													= 0x80E5, /** GL_COLOR_INDEX8_EXT */
		SL2_KIF_GL_COLOR_INDEX12_EXT												= 0x80E6, /** GL_COLOR_INDEX12_EXT */
		SL2_KIF_GL_COLOR_INDEX16_EXT												= 0x80E7, /** GL_COLOR_INDEX16_EXT */
		//
		// Depth/stencil
		//
		SL2_KIF_GL_DEPTH_COMPONENT16												= 0x81A5, /** GL_DEPTH_COMPONENT16 */
		SL2_KIF_GL_DEPTH_COMPONENT24												= 0x81A6, /** GL_DEPTH_COMPONENT24 */
		SL2_KIF_GL_DEPTH_COMPONENT32												= 0x81A7, /** GL_DEPTH_COMPONENT32 */
		SL2_KIF_GL_DEPTH_COMPONENT32F												= 0x8CAC, /** GL_DEPTH_COMPONENT32F */
		SL2_KIF_GL_DEPTH_COMPONENT32F_NV											= 0x8DAB, /** GL_DEPTH_COMPONENT32F_NV */
		SL2_KIF_GL_STENCIL_INDEX1													= 0x8D46, /** GL_STENCIL_INDEX1 */
		SL2_KIF_GL_STENCIL_INDEX4													= 0x8D47, /** GL_STENCIL_INDEX4 */
		SL2_KIF_GL_STENCIL_INDEX8													= 0x8D48, /** GL_STENCIL_INDEX8 */
		SL2_KIF_GL_STENCIL_INDEX16													= 0x8D49, /** GL_STENCIL_INDEX16 */
		SL2_KIF_GL_DEPTH24_STENCIL8													= 0x88F0, /** GL_DEPTH24_STENCIL8 */
		SL2_KIF_GL_DEPTH32F_STENCIL8												= 0x8CAD, /** GL_DEPTH32F_STENCIL8 */
		SL2_KIF_GL_DEPTH32F_STENCIL8_NV												= 0x8DAC, /** GL_DEPTH32F_STENCIL8_NV */
	};

	/**
	 * glBaseInternalFormat values.  Table 8.11 of OpenGL 4.4.
	 */
	enum SL2_KTX_BASE_INTERNAL_FORMAT : uint16_t {
		SL2_KBIF_GL_INVALID															= 0,
		SL2_KBIF_GL_RED																= 0x1903, /** GL_RED */
		SL2_KBIF_GL_GREEN															= 0x1904, /** GL_GREEN */
		SL2_KBIF_GL_BLUE															= 0x1905, /** GL_BLUE */
		SL2_KBIF_GL_ALPHA															= 0x1906, /** GL_ALPHA */
		SL2_KBIF_GL_LUMINANCE														= 0x1909, /** GL_LUMINANCE */
		SL2_KBIF_GL_SLUMINANCE														= 0x8C46, /** GL_SLUMINANCE */
		SL2_KBIF_GL_LUMINANCE_ALPHA													= 0x190A, /** GL_LUMINANCE_ALPHA */
		SL2_KBIF_GL_SLUMINANCE_ALPHA												= 0x8C44, /** GL_SLUMINANCE_ALPHA */
		SL2_KBIF_GL_INTENSITY														= 0x8049, /** GL_INTENSITY */
		SL2_KBIF_GL_RG																= 0x8227, /** GL_RG */
		SL2_KBIF_GL_RGB																= 0x1907, /** GL_RGB */
		SL2_KBIF_GL_BGR																= 0x80E0, /** GL_BGR */
		SL2_KBIF_GL_RGBA															= 0x1908, /** GL_RGBA */
		SL2_KBIF_GL_BGRA															= 0x80E1, /** GL_BGRA */
		SL2_KBIF_GL_RED_INTEGER														= 0x8D94, /** GL_RED_INTEGER */
		SL2_KBIF_GL_GREEN_INTEGER													= 0x8D95, /** GL_GREEN_INTEGER */
		SL2_KBIF_GL_BLUE_INTEGER													= 0x8D96, /** GL_BLUE_INTEGER */
		SL2_KBIF_GL_ALPHA_INTEGER													= 0x8D97, /** GL_ALPHA_INTEGER */
		SL2_KBIF_GL_LUMINANCE_INTEGER												= 0x8D9C, /** GL_LUMINANCE_INTEGER */
		SL2_KBIF_GL_LUMINANCE_ALPHA_INTEGER											= 0x8D9D, /** GL_LUMINANCE_ALPHA_INTEGER */
		SL2_KBIF_GL_RG_INTEGER														= 0x8228, /** GL_RG_INTEGER */
		SL2_KBIF_GL_RGB_INTEGER														= 0x8D98, /** GL_RGB_INTEGER */
		SL2_KBIF_GL_BGR_INTEGER														= 0x8D9A, /** GL_BGR_INTEGER */
		SL2_KBIF_GL_RGBA_INTEGER													= 0x8D99, /** GL_RGBA_INTEGER */
		SL2_KBIF_GL_BGRA_INTEGER													= 0x8D9B, /** GL_BGRA_INTEGER */
		SL2_KBIF_GL_COLOR_INDEX														= 0x1900, /** GL_COLOR_INDEX */
		SL2_KBIF_GL_STENCIL_INDEX													= 0x1901, /** GL_STENCIL_INDEX */
		SL2_KBIF_GL_DEPTH_COMPONENT													= 0x1902, /** GL_DEPTH_COMPONENT */
		SL2_KBIF_GL_DEPTH_STENCIL													= 0x84F9, /** GL_DEPTH_STENCIL */
		SL2_KBIF_0																	= 0,
	};

	/**
	 * VkFormat values.
	 */
	enum SL2_VKFORMAT : int32_t {
		SL2_VK_FORMAT_UNDEFINED = 0,
		SL2_VK_FORMAT_R4G4_UNORM_PACK8 = 1,
		SL2_VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
		SL2_VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
		SL2_VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
		SL2_VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
		SL2_VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
		SL2_VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
		SL2_VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
		SL2_VK_FORMAT_R8_UNORM = 9,
		SL2_VK_FORMAT_R8_SNORM = 10,
		SL2_VK_FORMAT_R8_USCALED = 11,
		SL2_VK_FORMAT_R8_SSCALED = 12,
		SL2_VK_FORMAT_R8_UINT = 13,
		SL2_VK_FORMAT_R8_SINT = 14,
		SL2_VK_FORMAT_R8_SRGB = 15,
		SL2_VK_FORMAT_R8G8_UNORM = 16,
		SL2_VK_FORMAT_R8G8_SNORM = 17,
		SL2_VK_FORMAT_R8G8_USCALED = 18,
		SL2_VK_FORMAT_R8G8_SSCALED = 19,
		SL2_VK_FORMAT_R8G8_UINT = 20,
		SL2_VK_FORMAT_R8G8_SINT = 21,
		SL2_VK_FORMAT_R8G8_SRGB = 22,
		SL2_VK_FORMAT_R8G8B8_UNORM = 23,
		SL2_VK_FORMAT_R8G8B8_SNORM = 24,
		SL2_VK_FORMAT_R8G8B8_USCALED = 25,
		SL2_VK_FORMAT_R8G8B8_SSCALED = 26,
		SL2_VK_FORMAT_R8G8B8_UINT = 27,
		SL2_VK_FORMAT_R8G8B8_SINT = 28,
		SL2_VK_FORMAT_R8G8B8_SRGB = 29,
		SL2_VK_FORMAT_B8G8R8_UNORM = 30,
		SL2_VK_FORMAT_B8G8R8_SNORM = 31,
		SL2_VK_FORMAT_B8G8R8_USCALED = 32,
		SL2_VK_FORMAT_B8G8R8_SSCALED = 33,
		SL2_VK_FORMAT_B8G8R8_UINT = 34,
		SL2_VK_FORMAT_B8G8R8_SINT = 35,
		SL2_VK_FORMAT_B8G8R8_SRGB = 36,
		SL2_VK_FORMAT_R8G8B8A8_UNORM = 37,
		SL2_VK_FORMAT_R8G8B8A8_SNORM = 38,
		SL2_VK_FORMAT_R8G8B8A8_USCALED = 39,
		SL2_VK_FORMAT_R8G8B8A8_SSCALED = 40,
		SL2_VK_FORMAT_R8G8B8A8_UINT = 41,
		SL2_VK_FORMAT_R8G8B8A8_SINT = 42,
		SL2_VK_FORMAT_R8G8B8A8_SRGB = 43,
		SL2_VK_FORMAT_B8G8R8A8_UNORM = 44,
		SL2_VK_FORMAT_B8G8R8A8_SNORM = 45,
		SL2_VK_FORMAT_B8G8R8A8_USCALED = 46,
		SL2_VK_FORMAT_B8G8R8A8_SSCALED = 47,
		SL2_VK_FORMAT_B8G8R8A8_UINT = 48,
		SL2_VK_FORMAT_B8G8R8A8_SINT = 49,
		SL2_VK_FORMAT_B8G8R8A8_SRGB = 50,
		SL2_VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
		SL2_VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
		SL2_VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
		SL2_VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
		SL2_VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
		SL2_VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
		SL2_VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
		SL2_VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
		SL2_VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
		SL2_VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
		SL2_VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
		SL2_VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
		SL2_VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
		SL2_VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
		SL2_VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
		SL2_VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
		SL2_VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
		SL2_VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
		SL2_VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
		SL2_VK_FORMAT_R16_UNORM = 70,
		SL2_VK_FORMAT_R16_SNORM = 71,
		SL2_VK_FORMAT_R16_USCALED = 72,
		SL2_VK_FORMAT_R16_SSCALED = 73,
		SL2_VK_FORMAT_R16_UINT = 74,
		SL2_VK_FORMAT_R16_SINT = 75,
		SL2_VK_FORMAT_R16_SFLOAT = 76,
		SL2_VK_FORMAT_R16G16_UNORM = 77,
		SL2_VK_FORMAT_R16G16_SNORM = 78,
		SL2_VK_FORMAT_R16G16_USCALED = 79,
		SL2_VK_FORMAT_R16G16_SSCALED = 80,
		SL2_VK_FORMAT_R16G16_UINT = 81,
		SL2_VK_FORMAT_R16G16_SINT = 82,
		SL2_VK_FORMAT_R16G16_SFLOAT = 83,
		SL2_VK_FORMAT_R16G16B16_UNORM = 84,
		SL2_VK_FORMAT_R16G16B16_SNORM = 85,
		SL2_VK_FORMAT_R16G16B16_USCALED = 86,
		SL2_VK_FORMAT_R16G16B16_SSCALED = 87,
		SL2_VK_FORMAT_R16G16B16_UINT = 88,
		SL2_VK_FORMAT_R16G16B16_SINT = 89,
		SL2_VK_FORMAT_R16G16B16_SFLOAT = 90,
		SL2_VK_FORMAT_R16G16B16A16_UNORM = 91,
		SL2_VK_FORMAT_R16G16B16A16_SNORM = 92,
		SL2_VK_FORMAT_R16G16B16A16_USCALED = 93,
		SL2_VK_FORMAT_R16G16B16A16_SSCALED = 94,
		SL2_VK_FORMAT_R16G16B16A16_UINT = 95,
		SL2_VK_FORMAT_R16G16B16A16_SINT = 96,
		SL2_VK_FORMAT_R16G16B16A16_SFLOAT = 97,
		SL2_VK_FORMAT_R32_UINT = 98,
		SL2_VK_FORMAT_R32_SINT = 99,
		SL2_VK_FORMAT_R32_SFLOAT = 100,
		SL2_VK_FORMAT_R32G32_UINT = 101,
		SL2_VK_FORMAT_R32G32_SINT = 102,
		SL2_VK_FORMAT_R32G32_SFLOAT = 103,
		SL2_VK_FORMAT_R32G32B32_UINT = 104,
		SL2_VK_FORMAT_R32G32B32_SINT = 105,
		SL2_VK_FORMAT_R32G32B32_SFLOAT = 106,
		SL2_VK_FORMAT_R32G32B32A32_UINT = 107,
		SL2_VK_FORMAT_R32G32B32A32_SINT = 108,
		SL2_VK_FORMAT_R32G32B32A32_SFLOAT = 109,
		SL2_VK_FORMAT_R64_UINT = 110,
		SL2_VK_FORMAT_R64_SINT = 111,
		SL2_VK_FORMAT_R64_SFLOAT = 112,
		SL2_VK_FORMAT_R64G64_UINT = 113,
		SL2_VK_FORMAT_R64G64_SINT = 114,
		SL2_VK_FORMAT_R64G64_SFLOAT = 115,
		SL2_VK_FORMAT_R64G64B64_UINT = 116,
		SL2_VK_FORMAT_R64G64B64_SINT = 117,
		SL2_VK_FORMAT_R64G64B64_SFLOAT = 118,
		SL2_VK_FORMAT_R64G64B64A64_UINT = 119,
		SL2_VK_FORMAT_R64G64B64A64_SINT = 120,
		SL2_VK_FORMAT_R64G64B64A64_SFLOAT = 121,
		SL2_VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
		SL2_VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
		SL2_VK_FORMAT_D16_UNORM = 124,
		SL2_VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
		SL2_VK_FORMAT_D32_SFLOAT = 126,
		SL2_VK_FORMAT_S8_UINT = 127,
		SL2_VK_FORMAT_D16_UNORM_S8_UINT = 128,
		SL2_VK_FORMAT_D24_UNORM_S8_UINT = 129,
		SL2_VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
		SL2_VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
		SL2_VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
		SL2_VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
		SL2_VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
		SL2_VK_FORMAT_BC2_UNORM_BLOCK = 135,
		SL2_VK_FORMAT_BC2_SRGB_BLOCK = 136,
		SL2_VK_FORMAT_BC3_UNORM_BLOCK = 137,
		SL2_VK_FORMAT_BC3_SRGB_BLOCK = 138,
		SL2_VK_FORMAT_BC4_UNORM_BLOCK = 139,
		SL2_VK_FORMAT_BC4_SNORM_BLOCK = 140,
		SL2_VK_FORMAT_BC5_UNORM_BLOCK = 141,
		SL2_VK_FORMAT_BC5_SNORM_BLOCK = 142,
		SL2_VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
		SL2_VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
		SL2_VK_FORMAT_BC7_UNORM_BLOCK = 145,
		SL2_VK_FORMAT_BC7_SRGB_BLOCK = 146,
		SL2_VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
		SL2_VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
		SL2_VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
		SL2_VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
		SL2_VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
		SL2_VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
		SL2_VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
		SL2_VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
		SL2_VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
		SL2_VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
		SL2_VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
		SL2_VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
		SL2_VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
		SL2_VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
		SL2_VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
		SL2_VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
		SL2_VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
		SL2_VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
		SL2_VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
		SL2_VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
		SL2_VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
		SL2_VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
		SL2_VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
		SL2_VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
		SL2_VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
		SL2_VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
		SL2_VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
		SL2_VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
		SL2_VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
		SL2_VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
		SL2_VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
		SL2_VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
		SL2_VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
		SL2_VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
		SL2_VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
		SL2_VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
		SL2_VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
		SL2_VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032,
		// Provided by SL2_VK_VERSION_1_1
		SL2_VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033,
		// Provided by SL2_VK_VERSION_1_3
		SL2_VK_FORMAT_G8_B8R8_2PLANE_444_UNORM = 1000330000,
		// Provided by SL2_VK_VERSION_1_3
		SL2_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16 = 1000330001,
		// Provided by SL2_VK_VERSION_1_3
		SL2_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16 = 1000330002,
		// Provided by SL2_VK_VERSION_1_3
		SL2_VK_FORMAT_G16_B16R16_2PLANE_444_UNORM = 1000330003,
		// Provided by SL2_VK_VERSION_1_3
		SL2_VK_FORMAT_A4R4G4B4_UNORM_PACK16 = 1000340000,
		// Provided by SL2_VK_VERSION_1_3
		SL2_VK_FORMAT_A4B4G4R4_UNORM_PACK16 = 1000340001,
		// Provided by SL2_VK_VERSION_1_3
		SL2_VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK = 1000066000,
		// Provided by SL2_VK_VERSION_1_3
		SL2_VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK = 1000066001,
		// Provided by SL2_VK_VERSION_1_3
		SL2_VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK = 1000066002,
		// Provided by SL2_VK_VERSION_1_3
		SL2_VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK = 1000066003,
		// Provided by SL2_VK_VERSION_1_3
		SL2_VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK = 1000066004,
		// Provided by SL2_VK_VERSION_1_3
		SL2_VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK = 1000066005,
		// Provided by SL2_VK_VERSION_1_3
		SL2_VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK = 1000066006,
		// Provided by SL2_VK_VERSION_1_3
		SL2_VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK = 1000066007,
		// Provided by SL2_VK_VERSION_1_3
		SL2_VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK = 1000066008,
		// Provided by SL2_VK_VERSION_1_3
		SL2_VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK = 1000066009,
		// Provided by SL2_VK_VERSION_1_3
		SL2_VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK = 1000066010,
		// Provided by SL2_VK_VERSION_1_3
		SL2_VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK = 1000066011,
		// Provided by SL2_VK_VERSION_1_3
		SL2_VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK = 1000066012,
		// Provided by SL2_VK_VERSION_1_3
		SL2_VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK = 1000066013,
		// Provided by SL2_VK_IMG_format_pvrtc
		SL2_VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
		// Provided by SL2_VK_IMG_format_pvrtc
		SL2_VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
		// Provided by SL2_VK_IMG_format_pvrtc
		SL2_VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
		// Provided by SL2_VK_IMG_format_pvrtc
		SL2_VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
		// Provided by SL2_VK_IMG_format_pvrtc
		SL2_VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
		// Provided by SL2_VK_IMG_format_pvrtc
		SL2_VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
		// Provided by SL2_VK_IMG_format_pvrtc
		SL2_VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
		// Provided by SL2_VK_IMG_format_pvrtc
		SL2_VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
		// Provided by SL2_VK_NV_optical_flow
		SL2_VK_FORMAT_R16G16_S10_5_NV = 1000464000,
		// Provided by SL2_VK_KHR_maintenance5
		SL2_VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR = 1000470000,
		// Provided by SL2_VK_KHR_maintenance5
		SL2_VK_FORMAT_A8_UNORM_KHR = 1000470001,
		// Provided by SL2_VK_EXT_texture_compression_astc_hdr
		SL2_VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT = SL2_VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK,
		// Provided by SL2_VK_EXT_texture_compression_astc_hdr
		SL2_VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT = SL2_VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK,
		// Provided by SL2_VK_EXT_texture_compression_astc_hdr
		SL2_VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT = SL2_VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK,
		// Provided by SL2_VK_EXT_texture_compression_astc_hdr
		SL2_VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT = SL2_VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK,
		// Provided by SL2_VK_EXT_texture_compression_astc_hdr
		SL2_VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT = SL2_VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK,
		// Provided by SL2_VK_EXT_texture_compression_astc_hdr
		SL2_VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT = SL2_VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK,
		// Provided by SL2_VK_EXT_texture_compression_astc_hdr
		SL2_VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT = SL2_VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK,
		// Provided by SL2_VK_EXT_texture_compression_astc_hdr
		SL2_VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT = SL2_VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK,
		// Provided by SL2_VK_EXT_texture_compression_astc_hdr
		SL2_VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT = SL2_VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK,
		// Provided by SL2_VK_EXT_texture_compression_astc_hdr
		SL2_VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT = SL2_VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK,
		// Provided by SL2_VK_EXT_texture_compression_astc_hdr
		SL2_VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT = SL2_VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK,
		// Provided by SL2_VK_EXT_texture_compression_astc_hdr
		SL2_VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT = SL2_VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK,
		// Provided by SL2_VK_EXT_texture_compression_astc_hdr
		SL2_VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT = SL2_VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK,
		// Provided by SL2_VK_EXT_texture_compression_astc_hdr
		SL2_VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT = SL2_VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G8B8G8R8_422_UNORM_KHR = SL2_VK_FORMAT_G8B8G8R8_422_UNORM,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_B8G8R8G8_422_UNORM_KHR = SL2_VK_FORMAT_B8G8R8G8_422_UNORM,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR = SL2_VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR = SL2_VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR = SL2_VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR = SL2_VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR = SL2_VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_R10X6_UNORM_PACK16_KHR = SL2_VK_FORMAT_R10X6_UNORM_PACK16,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR = SL2_VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = SL2_VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = SL2_VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = SL2_VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = SL2_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = SL2_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = SL2_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = SL2_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = SL2_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_R12X4_UNORM_PACK16_KHR = SL2_VK_FORMAT_R12X4_UNORM_PACK16,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR = SL2_VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = SL2_VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = SL2_VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = SL2_VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = SL2_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = SL2_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = SL2_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = SL2_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = SL2_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G16B16G16R16_422_UNORM_KHR = SL2_VK_FORMAT_G16B16G16R16_422_UNORM,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_B16G16R16G16_422_UNORM_KHR = SL2_VK_FORMAT_B16G16R16G16_422_UNORM,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR = SL2_VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR = SL2_VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR = SL2_VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR = SL2_VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
		// Provided by SL2_VK_KHR_sampler_ycbcr_conversion
		SL2_VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR = SL2_VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM,
		// Provided by SL2_VK_EXT_ycbcr_2plane_444_formats
		SL2_VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT = SL2_VK_FORMAT_G8_B8R8_2PLANE_444_UNORM,
		// Provided by SL2_VK_EXT_ycbcr_2plane_444_formats
		SL2_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT = SL2_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16,
		// Provided by SL2_VK_EXT_ycbcr_2plane_444_formats
		SL2_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT = SL2_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16,
		// Provided by SL2_VK_EXT_ycbcr_2plane_444_formats
		SL2_VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT = SL2_VK_FORMAT_G16_B16R16_2PLANE_444_UNORM,
		// Provided by SL2_VK_EXT_4444_formats
		SL2_VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT = SL2_VK_FORMAT_A4R4G4B4_UNORM_PACK16,
		// Provided by SL2_VK_EXT_4444_formats
		SL2_VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT = SL2_VK_FORMAT_A4B4G4R4_UNORM_PACK16,
		SL2_VK_FORMAT_MAX_ENUM														= 0x7FFFFFFF
	};

	/**
	 * DXGI_FORMAT values.
	 **/
	enum SL2_DXGI_FORMAT : uint32_t {
		SL2_DXGI_FORMAT_UNKNOWN														= 0,
		SL2_DXGI_FORMAT_R32G32B32A32_TYPELESS										= 1,
		SL2_DXGI_FORMAT_R32G32B32A32_FLOAT											= 2,
		SL2_DXGI_FORMAT_R32G32B32A32_UINT											= 3,
		SL2_DXGI_FORMAT_R32G32B32A32_SINT											= 4,
		SL2_DXGI_FORMAT_R32G32B32_TYPELESS											= 5,
		SL2_DXGI_FORMAT_R32G32B32_FLOAT												= 6,
		SL2_DXGI_FORMAT_R32G32B32_UINT												= 7,
		SL2_DXGI_FORMAT_R32G32B32_SINT												= 8,
		SL2_DXGI_FORMAT_R16G16B16A16_TYPELESS										= 9,
		SL2_DXGI_FORMAT_R16G16B16A16_FLOAT											= 10,
		SL2_DXGI_FORMAT_R16G16B16A16_UNORM											= 11,
		SL2_DXGI_FORMAT_R16G16B16A16_UINT											= 12,
		SL2_DXGI_FORMAT_R16G16B16A16_SNORM											= 13,
		SL2_DXGI_FORMAT_R16G16B16A16_SINT											= 14,
		SL2_DXGI_FORMAT_R32G32_TYPELESS												= 15,
		SL2_DXGI_FORMAT_R32G32_FLOAT												= 16,
		SL2_DXGI_FORMAT_R32G32_UINT													= 17,
		SL2_DXGI_FORMAT_R32G32_SINT													= 18,
		SL2_DXGI_FORMAT_R32G8X24_TYPELESS											= 19,
		SL2_DXGI_FORMAT_D32_FLOAT_S8X24_UINT										= 20,
		SL2_DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS									= 21,
		SL2_DXGI_FORMAT_X32_TYPELESS_G8X24_UINT										= 22,
		SL2_DXGI_FORMAT_R10G10B10A2_TYPELESS										= 23,
		SL2_DXGI_FORMAT_R10G10B10A2_UNORM											= 24,
		SL2_DXGI_FORMAT_R10G10B10A2_UINT											= 25,
		SL2_DXGI_FORMAT_R11G11B10_FLOAT												= 26,
		SL2_DXGI_FORMAT_R8G8B8A8_TYPELESS											= 27,
		SL2_DXGI_FORMAT_R8G8B8A8_UNORM												= 28,
		SL2_DXGI_FORMAT_R8G8B8A8_UNORM_SRGB											= 29,
		SL2_DXGI_FORMAT_R8G8B8A8_UINT												= 30,
		SL2_DXGI_FORMAT_R8G8B8A8_SNORM												= 31,
		SL2_DXGI_FORMAT_R8G8B8A8_SINT												= 32,
		SL2_DXGI_FORMAT_R16G16_TYPELESS												= 33,
		SL2_DXGI_FORMAT_R16G16_FLOAT												= 34,
		SL2_DXGI_FORMAT_R16G16_UNORM												= 35,
		SL2_DXGI_FORMAT_R16G16_UINT													= 36,
		SL2_DXGI_FORMAT_R16G16_SNORM												= 37,
		SL2_DXGI_FORMAT_R16G16_SINT													= 38,
		SL2_DXGI_FORMAT_R32_TYPELESS												= 39,
		SL2_DXGI_FORMAT_D32_FLOAT													= 40,
		SL2_DXGI_FORMAT_R32_FLOAT													= 41,
		SL2_DXGI_FORMAT_R32_UINT													= 42,
		SL2_DXGI_FORMAT_R32_SINT													= 43,
		SL2_DXGI_FORMAT_R24G8_TYPELESS												= 44,
		SL2_DXGI_FORMAT_D24_UNORM_S8_UINT											= 45,
		SL2_DXGI_FORMAT_R24_UNORM_X8_TYPELESS										= 46,
		SL2_DXGI_FORMAT_X24_TYPELESS_G8_UINT										= 47,
		SL2_DXGI_FORMAT_R8G8_TYPELESS												= 48,
		SL2_DXGI_FORMAT_R8G8_UNORM													= 49,
		SL2_DXGI_FORMAT_R8G8_UINT													= 50,
		SL2_DXGI_FORMAT_R8G8_SNORM													= 51,
		SL2_DXGI_FORMAT_R8G8_SINT													= 52,
		SL2_DXGI_FORMAT_R16_TYPELESS												= 53,
		SL2_DXGI_FORMAT_R16_FLOAT													= 54,
		SL2_DXGI_FORMAT_D16_UNORM													= 55,
		SL2_DXGI_FORMAT_R16_UNORM													= 56,
		SL2_DXGI_FORMAT_R16_UINT													= 57,
		SL2_DXGI_FORMAT_R16_SNORM													= 58,
		SL2_DXGI_FORMAT_R16_SINT													= 59,
		SL2_DXGI_FORMAT_R8_TYPELESS													= 60,
		SL2_DXGI_FORMAT_R8_UNORM													= 61,
		SL2_DXGI_FORMAT_R8_UINT														= 62,
		SL2_DXGI_FORMAT_R8_SNORM													= 63,
		SL2_DXGI_FORMAT_R8_SINT														= 64,
		SL2_DXGI_FORMAT_A8_UNORM													= 65,
		SL2_DXGI_FORMAT_R1_UNORM													= 66,
		SL2_DXGI_FORMAT_R9G9B9E5_SHAREDEXP											= 67,
		SL2_DXGI_FORMAT_R8G8_B8G8_UNORM												= 68,
		SL2_DXGI_FORMAT_G8R8_G8B8_UNORM												= 69,
		SL2_DXGI_FORMAT_BC1_TYPELESS												= 70,
		SL2_DXGI_FORMAT_BC1_UNORM													= 71,
		SL2_DXGI_FORMAT_BC1_UNORM_SRGB												= 72,
		SL2_DXGI_FORMAT_BC2_TYPELESS												= 73,
		SL2_DXGI_FORMAT_BC2_UNORM													= 74,
		SL2_DXGI_FORMAT_BC2_UNORM_SRGB												= 75,
		SL2_DXGI_FORMAT_BC3_TYPELESS												= 76,
		SL2_DXGI_FORMAT_BC3_UNORM													= 77,
		SL2_DXGI_FORMAT_BC3_UNORM_SRGB												= 78,
		SL2_DXGI_FORMAT_BC4_TYPELESS												= 79,
		SL2_DXGI_FORMAT_BC4_UNORM													= 80,
		SL2_DXGI_FORMAT_BC4_SNORM													= 81,
		SL2_DXGI_FORMAT_BC5_TYPELESS												= 82,
		SL2_DXGI_FORMAT_BC5_UNORM													= 83,
		SL2_DXGI_FORMAT_BC5_SNORM													= 84,
		SL2_DXGI_FORMAT_B5G6R5_UNORM												= 85,
		SL2_DXGI_FORMAT_B5G5R5A1_UNORM												= 86,
		SL2_DXGI_FORMAT_B8G8R8A8_UNORM												= 87,
		SL2_DXGI_FORMAT_B8G8R8X8_UNORM												= 88,
		SL2_DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM									= 89,
		SL2_DXGI_FORMAT_B8G8R8A8_TYPELESS											= 90,
		SL2_DXGI_FORMAT_B8G8R8A8_UNORM_SRGB											= 91,
		SL2_DXGI_FORMAT_B8G8R8X8_TYPELESS											= 92,
		SL2_DXGI_FORMAT_B8G8R8X8_UNORM_SRGB											= 93,
		SL2_DXGI_FORMAT_BC6H_TYPELESS												= 94,
		SL2_DXGI_FORMAT_BC6H_UF16													= 95,
		SL2_DXGI_FORMAT_BC6H_SF16													= 96,
		SL2_DXGI_FORMAT_BC7_TYPELESS												= 97,
		SL2_DXGI_FORMAT_BC7_UNORM													= 98,
		SL2_DXGI_FORMAT_BC7_UNORM_SRGB												= 99,
		SL2_DXGI_FORMAT_AYUV														= 100,
		SL2_DXGI_FORMAT_Y410														= 101,
		SL2_DXGI_FORMAT_Y416														= 102,
		SL2_DXGI_FORMAT_NV12														= 103,
		SL2_DXGI_FORMAT_P010														= 104,
		SL2_DXGI_FORMAT_P016														= 105,
		SL2_DXGI_FORMAT_420_OPAQUE													= 106,
		SL2_DXGI_FORMAT_YUY2														= 107,
		SL2_DXGI_FORMAT_Y210														= 108,
		SL2_DXGI_FORMAT_Y216														= 109,
		SL2_DXGI_FORMAT_NV11														= 110,
		SL2_DXGI_FORMAT_AI44														= 111,
		SL2_DXGI_FORMAT_IA44														= 112,
		SL2_DXGI_FORMAT_P8															= 113,
		SL2_DXGI_FORMAT_A8P8														= 114,
		SL2_DXGI_FORMAT_B4G4R4A4_UNORM												= 115,
		SL2_DXGI_FORMAT_P208														= 130,
		SL2_DXGI_FORMAT_V208														= 131,
		SL2_DXGI_FORMAT_V408														= 132,
		SL2_DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE,
		SL2_DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE,
		SL2_DXGI_FORMAT_FORCE_UINT = 0xFFFFFFFF
	};

	/**
	 * MTLPixelFormat values.
	 */
	enum SL2_MTLPIXELFORMAT : int32_t {
		SL2_MTLPixelFormatA1BGR5Unorm	= 41,	// Indicates the unsigned, normalized integer format.
		SL2_MTLPixelFormatA8Unorm	= 1,	// Indicates the unsigned, normalized integer format.
		SL2_MTLPixelFormatABGR4Unorm	= 42,	// Indicates the unsigned, normalized integer format.
		SL2_MTLPixelFormatASTC_10x10_LDR	= 216,	// Indicates the 10x10 ASTC, low dynamic range format.
		SL2_MTLPixelFormatASTC_10x10_sRGB	= 198,	// Indicates the 10x10 ASTC format, with sRGB-Linear conversion.
		SL2_MTLPixelFormatASTC_10x5_LDR	= 213,	// Indicates the 10x5 ASTC, low dynamic range format.
		SL2_MTLPixelFormatASTC_10x5_sRGB	= 195,	// Indicates the 10x5 ASTC format, with sRGB-Linear conversion.
		SL2_MTLPixelFormatASTC_10x6_LDR	= 214,	// Indicates the 10x6 ASTC, low dynamic range format.
		SL2_MTLPixelFormatASTC_10x6_sRGB	= 196,	// Indicates the 10x6 ASTC format, with sRGB-Linear conversion.
		SL2_MTLPixelFormatASTC_10x8_LDR	= 215,	// Indicates the 10x8 ASTC, low dynamic range format.
		SL2_MTLPixelFormatASTC_10x8_sRGB	= 197,	// Indicates the 10x8 ASTC format, with sRGB-Linear conversion.
		SL2_MTLPixelFormatASTC_12x10_LDR	= 217,	// Indicates the 12x10 ASTC, low dynamic range format.
		SL2_MTLPixelFormatASTC_12x10_sRGB	= 199,	// Indicates the 12x10 ASTC format, with sRGB-Linear conversion.
		SL2_MTLPixelFormatASTC_12x12_LDR	= 218,	// Indicates the 12x12 ASTC, low dynamic range format.
		SL2_MTLPixelFormatASTC_12x12_sRGB	= 200,	// Indicates the 12x12 ASTC format, with sRGB-Linear conversion.
		SL2_MTLPixelFormatASTC_4x4_LDR	= 204,	// Indicates the 4x4 ASTC, low dynamic range format.
		SL2_MTLPixelFormatASTC_4x4_sRGB	= 186,	// Indicates the 4x4 ASTC format, with sRGB-Linear conversion.
		SL2_MTLPixelFormatASTC_5x4_LDR	= 205,	// Indicates the 5x4 ASTC, low dynamic range format.
		SL2_MTLPixelFormatASTC_5x4_sRGB	= 187,	// Indicates the 5x4 ASTC format, with sRGB-Linear conversion.
		SL2_MTLPixelFormatASTC_5x5_LDR	= 206,	// Indicates the 5x5 ASTC, low dynamic range format.
		SL2_MTLPixelFormatASTC_5x5_sRGB	= 188,	// Indicates the 5x5 ASTC format, with sRGB-Linear conversion.
		SL2_MTLPixelFormatASTC_6x5_LDR	= 207,	// Indicates the 6x5 ASTC, low dynamic range format.
		SL2_MTLPixelFormatASTC_6x5_sRGB	= 189,	// Indicates the 6x5 ASTC format, with sRGB-Linear conversion.
		SL2_MTLPixelFormatASTC_6x6_LDR	= 208,	// Indicates the 6x6 ASTC, low dynamic range format.
		SL2_MTLPixelFormatASTC_6x6_sRGB	= 190,	// Indicates the 6x6 ASTC format, with sRGB-Linear conversion.
		SL2_MTLPixelFormatASTC_8x5_LDR	= 210,	// Indicates the 8x5 ASTC, low dynamic range format.
		SL2_MTLPixelFormatASTC_8x5_sRGB	= 192,	// Indicates the 8x5 ASTC format, with sRGB-Linear conversion.
		SL2_MTLPixelFormatASTC_8x6_LDR	= 211,	// Indicates the 8x6 ASTC, low dynamic range format.
		SL2_MTLPixelFormatASTC_8x6_sRGB	= 193,	// Indicates the 8x6 ASTC format, with sRGB-Linear conversion.
		SL2_MTLPixelFormatASTC_8x8_LDR	= 212,	// Indicates the 8x8 ASTC, low dynamic range format.
		SL2_MTLPixelFormatASTC_8x8_sRGB	= 194,	// Indicates the 8x8 ASTC format, with sRGB-Linear conversion.
		SL2_MTLPixelFormatB5G6R5Unorm	= 40,	// Indicates a 5-bit B, 6-bit G, and 5-bit R unsigned, normalized integer format.
		SL2_MTLPixelFormatBGR10A2Unorm	= 94,	// Indicates a 10-bit B, 10-bit G, 10-bit R, and 2-bit Alpha normalized unsigned integer format.
		SL2_MTLPixelFormatBGR5A1Unorm	= 43,	// Indicates a 5-bit B, 6-bit G, 5-bit R, and 1-bit Alpha unnormalized signed integer format.
		SL2_MTLPixelFormatBGRA8Unorm	= 80,	// Indicates an 8-bit BGRA unnormalized signed integer format.
		SL2_MTLPixelFormatBGRA8Unorm_sRGB	= 81,	// Indicates an 8-bit BGRA unnormalized signed integer format with sRGB-Linear conversion
		SL2_MTLPixelFormatBGRG422	= 241,	// Indicates a red-green horizontally subsampled format.
		SL2_MTLPixelFormatDepth32Float	= 252,	// Indicates a 32-bit format that is suitable for depth stencils.
		SL2_MTLPixelFormatDepth32Float_Stencil8	= 260,	// Indicates a 24-bit depth and 8-bit stencil floating-point format.
		SL2_MTLPixelFormatEAC_R11Snorm	= 172,	// Indicates a single-channel EAC, normalized signed integer format.
		SL2_MTLPixelFormatEAC_R11Unorm	= 170,	// Indicates a single-channel EAC, unnormalized signed integer format.
		SL2_MTLPixelFormatEAC_RG11Snorm	= 176,	// Indicates a two-channel EAC, normalized signed integer format.
		SL2_MTLPixelFormatEAC_RG11Unorm	= 174,	// Indicates a two-channel EAC, unnormalized signed integer format.
		SL2_MTLPixelFormatEAC_RGBA8	= 178,	// Indicates an 8-bit RGB EAC format.
		SL2_MTLPixelFormatEAC_RGBA8_sRGB	= 179,	// Indicates an 8-bit RGBa EAC format with sRGB-Linear conversion.
		SL2_MTLPixelFormatETC2_RGB8	= 180,	// Indicates an ETC2 format.
		SL2_MTLPixelFormatETC2_RGB8_sRGB	= 181,	// Indicates an ETC2 format with sRGB-Linear conversion.
		SL2_MTLPixelFormatETC2_RGB8A1	= 182,	// Indicates an ETC2 format with 8-bit RGB channels and a single-bit Alpha channel.
		SL2_MTLPixelFormatETC2_RGB8A1_sRGB	= 183,	// Indicates an ETC2 format with 8-bit RGB channels and a single-bit Alpha channel, with sRGB-Linear conversion.
		SL2_MTLPixelFormatGBGR422	= 240,	// Indicates a red-green horizontally subsampled format.
		SL2_MTLPixelFormatInvalid	= 0,	// Indicates an invalid pixel format.
		SL2_MTLPixelFormatPVRTC_RGB_2BPP	= 160,	// Indicatea a 2bpp PVRTC RGB format.
		SL2_MTLPixelFormatPVRTC_RGB_2BPP_sRGB	= 161,	// Indicatea a 2bpp PVRTC RGB format with sRGB-Linear conversion.
		SL2_MTLPixelFormatPVRTC_RGB_4BPP	= 162,	// Indicatea a 4bpp PVRTC RGB format.
		SL2_MTLPixelFormatPVRTC_RGB_4BPP_sRGB	= 163,	// Indicatea a 4bpp PVRTC RGB format with sRGB-Linear conversion.
		SL2_MTLPixelFormatPVRTC_RGBA_2BPP	= 164,	// Indicatea a 2bpp PVRTC RGBA format.
		SL2_MTLPixelFormatPVRTC_RGBA_2BPP_sRGB	= 165,	// Indicatea a 2bpp PVRTC RGBA format with sRGB-Linear conversion.
		SL2_MTLPixelFormatPVRTC_RGBA_4BPP	= 166,	// Indicatea a 4bpp PVRTC RGBA format.
		SL2_MTLPixelFormatPVRTC_RGBA_4BPP_sRGB	= 167,	// Indicatea a 4bpp PVRTC RGBA format with sRGB-Linear conversion.
		SL2_MTLPixelFormatR16Float	= 25,	// Indicates a single 16-bit floating point format.
		SL2_MTLPixelFormatR16Sint	= 24,	// Indicates a single 16-bit signed integer format.
		SL2_MTLPixelFormatR16Snorm	= 22,	// Indicates a single 16-bit normalized integer format.
		SL2_MTLPixelFormatR16Uint	= 23,	// Indicates a single 16-bit unsigned integer format.
		SL2_MTLPixelFormatR16Unorm	= 20,	// Indicates a single 16-bit normalized integer format.
		SL2_MTLPixelFormatR32Float	= 55,	// Indicates a single 32-bit floating point format.
		SL2_MTLPixelFormatR32Sint	= 54,	// Indicates a single 32-bit signed integer format.
		SL2_MTLPixelFormatR32Uint	= 53,	// Indicates a single 32-bit unsigned integer format.
		SL2_MTLPixelFormatR8Sint	= 14,	// Indicates a single 8-bit signed integer format.
		SL2_MTLPixelFormatR8Snorm	= 12,	// Indicates a single 8-bit normalized integer format.
		SL2_MTLPixelFormatR8Uint	= 13,	// Indicates a single 8-bit unsigned integer format.
		SL2_MTLPixelFormatR8Unorm	= 10,	// Indicates a single 8-bit normalized integer format.
		SL2_MTLPixelFormatR8Unorm_sRGB	= 11,	// Indicates a single 8-bit unnormalized signed integer format with sRGB-Linear conversion.
		SL2_MTLPixelFormatRG11B10Float	= 92,	// Indicates an 11-bit RG plus 10-bit B value floating-point format.
		SL2_MTLPixelFormatRG16Float	= 65,	// Indicates a 2-channel floating point format with 16 bits per channel.
		SL2_MTLPixelFormatRG16Sint	= 64,	// Indicates a 2-channel signed integer format with 16 bits per channel.
		SL2_MTLPixelFormatRG16Snorm	= 62,	// Indicates a 2-channel normalized integer format with 16 bits per channel.
		SL2_MTLPixelFormatRG16Uint	= 63,	// Indicates a 2-channel unsigned integer format with 16 bits per channel.
		SL2_MTLPixelFormatRG16Unorm	= 60,	// Indicates a 2-channel unnormalized signed integer format with 16 bits per channel.
		SL2_MTLPixelFormatRG32Float	= 105,	// Indicates a 2-channel floating point format with 32 bits per channel.
		SL2_MTLPixelFormatRG32Sint	= 104,	// Indicates a 2-channel signed integer format with 32 bits per channel.
		SL2_MTLPixelFormatRG32Uint	= 103,	// Indicates a 2-channel unsigned integer format with 32 bits per channel.
		SL2_MTLPixelFormatRG8Sint	= 34,	// Indicates a 2-channel signed integer format with 8 bits per channel.
		SL2_MTLPixelFormatRG8Snorm	= 32,	// Indicates a 2-channel normalized signed integer format with 8 bits per channel.
		SL2_MTLPixelFormatRG8Uint	= 33,	// Indicates a 2-channel unsigned integer format with 8 bits per channel.
		SL2_MTLPixelFormatRG8Unorm	= 30,	// Indicates a 2-channel unnormalized signed integer format with 8 bits per channel.
		SL2_MTLPixelFormatRG8Unorm_sRGB	= 31,	// Indicates a 2-channel unnormalized signed integer format with 8 bits per channel and sRGB-Linear conversion.
		SL2_MTLPixelFormatRGB10A2Uint	= 91,	// Indicates a format with 10-bit unsigned integer RGB values plus 2 alpha bits.
		SL2_MTLPixelFormatRGB10A2Unorm	= 90,	// Indicates a format with 10-bit normalized unsigned integer RGB values plus 2 alpha bits.
		SL2_MTLPixelFormatRGB9E5Float	= 93,	// Indicates a format with 9 bits per RGB channel plus a 5-bit shared exponent.
		SL2_MTLPixelFormatRGBA16Float	= 115,	// Indicates a format with 4 16-bit floating point channels.
		SL2_MTLPixelFormatRGBA16Sint	= 114,	// Indicates a format with 4 16-bit signed integer channels.
		SL2_MTLPixelFormatRGBA16Snorm	= 112,	// Indicates a format with 4 16-bit normalized signed integer channels.
		SL2_MTLPixelFormatRGBA16Uint	= 113,	// Indicates a format with 4 16-bit unsigned integer channels.
		SL2_MTLPixelFormatRGBA16Unorm	= 110,	// Indicates a format with 4 16-bit normalized unsigned integer channels.
		SL2_MTLPixelFormatRGBA32Float	= 125,	// Indicates a format with 4 32-bit floating point channels.
		SL2_MTLPixelFormatRGBA32Sint	= 124,	// Indicates a format with 4 32-bit signed integer channels.
		SL2_MTLPixelFormatRGBA32Uint	= 123,	// Indicates a format with 4 32-bit unsigned integer channels.
		SL2_MTLPixelFormatRGBA8Sint	= 74,	// Indicates a format with 4 8-bit signed integer channels.
		SL2_MTLPixelFormatRGBA8Snorm	= 72,	// Indicates a format with 4 8-bit normalized signed integer channels.
		SL2_MTLPixelFormatRGBA8Uint	= 73,	// Indicates a format with 4 8-bit unsigned integer channels.
		SL2_MTLPixelFormatRGBA8Unorm	= 70,	// Indicates a format with 4 8-bit normalized unsigned integer channels.
		SL2_MTLPixelFormatRGBA8Unorm_sRGB	= 71,	// Indicates a format with 4 8-bit normalized unsigned integer channels, with sRGB-Linear conversion.
		SL2_MTLPixelFormatStencil8	= 253,	// Indicates a single-channel 8-bit stencil format.
		SL2_MTLPixelFormatX32_Stencil8	= 261,	// Indicates an 8-bit stencil format.
	};

	/**
	 * Compression scheme.
	 */
	enum SL2_COMPRESSION_SCHEME {
		SL2_CS_BC																	= 1,																/**< Block compression. */
		SL2_CS_ASTC																	= 2,																/**< Adaptive scalable texture compression. */
		SL2_CS_PVRTC																= 3,																/**< PowerVR Texture Compression. */
		SL2_CS_ETC																	= 4,																/**< Ericsson Texture Compression. */
		SL2_CS_FXT																	= 5,																/**< 3dfx Interactive fixed-rate block-based texture compression. */
		SL2_CS_ATC																	= 6,																/**< AMD Texture Compression. */
	};

	/**
	 * Component order.
	 */
	enum SL2_PIXEL_COMPONENTS {
		SL2_PC_R,																	/**< Red. */
		SL2_PC_G,																	/**< Green. */
		SL2_PC_B,																	/**< Blue. */
		SL2_PC_A,																	/**< Alpha. */
		SL2_PC_INVALID,																/**< Invalid. */
	};

	/** Luma coefficient standards. */
	enum SL2_LUMA_STANDARDS : uint8_t {
		SL2_LS_REC_709 = 0,															/**< Rec. 709 (used for HDTV). */
		SL2_LS_REC_2020 = 1,														/**< Rec. 2020 (used for UHDTV, 4K, 8K). */
		SL2_LS_SMPTC = 2,															/**< SMPTE C (used for older American NTSC television). */
		SL2_LS_REC_601 = 3,															/**< ITU-R BT.601 (Rec. 601) (used for the conversion from RGB to YCbCr in standard definition television). */
		SL2_LS_CIE_1931 = 4,														/**< CIE 1931 RGB (defined by the International Commission on Illumination (CIE) in 1931 and is one of the first mathematically defined color spaces that related human color perception to physical measures of color). */
		SL2_LS_NTSC_1953 = 5,														/**< NTSC (1953) (an older standard used in the initial color television system in North America). */
		SL2_LS_EBU_TECH_3213 = 6,													/**< EBU Tech 3213 (PAL/SECAM) (used in European broadcasting, similar to NTSC but with slightly different coefficients). */
		SL2_LS_TOTAL
	};

	/**
	 * Class CFormat
	 * \brief All of the image formats, along with conversion routines and functions for working with the formats (encoding, decoding, etc.)
	 *
	 * Description: All of the image formats, along with conversion routines and functions for working with the formats (encoding, decoding, etc.)
	 */
	class CFormat {
	public :
		// == Types.
		/** The compression-size calculator. */
		typedef uint32_t															(* PfCompSizeFunc)( uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, uint32_t _ui32Factor, const void * _pvParms );

		/** Function type for converting from any SL2_KTX_INTERNAL_FORMAT to RGBA64F. */
		typedef bool																(* PfToRgba64F)( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms );

		/** Function type for converting from RGBA64F to an SL2_KTX_INTERNAL_FORMATformat. */
		typedef bool																(* PfFromRgba64F)( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms );

		/** Internal format data. */
		typedef struct SL2_KTX_INTERNAL_FORMAT_DATA {
			/** The name of the Vulkan format. */
			const char *															pcVulkanName;
			/** The name of the Direct3D 12 format. */
			const char *															pcDxName;
			/** The name of the Metal format. */
			const char *															pcMetalName;
			/** The OpenGL internal format. */
			const char *															pcOglInternalFormat;
			/** The OpenGL type. */
			const char *															pcOglType;
			/** The OpenGL base internal format. */
			const char *															pcOglBaseInternalFormat;
			/** The Vulkan format. */
			SL2_VKFORMAT															vfVulkanFormat;
			/** The Direct3D 12 format. */
			SL2_DXGI_FORMAT															dfDxFormat;
			/** The Metal format. */
			SL2_MTLPIXELFORMAT														mfMetalFormat;
			/** The format identifier. */
			SL2_KTX_INTERNAL_FORMAT													kifInternalFormat;
			/** The type. */
			SL2_KTX_TYPE															ktType;
			/** The internal base format. */
			SL2_KTX_BASE_INTERNAL_FORMAT											kbifBaseInternalFormat;
			/** KTX flags. */
			uint32_t																ui32Flags;
			/** Palette size in bits. */
			uint32_t																ui32PaletteSizeInBits;
			/** Block size in bits. */
			uint32_t																ui32BlockSizeInBits;
			/** Block width. */
			uint32_t																ui32BlockWidth;
			/** Block height. */
			uint32_t																ui32BlockHeight;
			/** Block depth. */
			uint32_t																ui32BlockDepth;
			/** Minimum blocks X. */
			uint32_t																ui32MinBlocksX;
			/** Minimum blocks Y. */
			uint32_t																ui32MinBlocksY;
			/** Is it sRGB? */
			bool																	bSrgb;
			/** Is it compressed? */
			bool																	bCompressed;
			/** Is it a palette type? */
			bool																	bPalette;
			/** Is it a floating-point or HDR format/non-integer? */
			bool																	bFloatFormat;
			/** Function for getting its compressed size. */
			PfCompSizeFunc															pfCompSizeFunc;
			/** R bit count. */
			uint8_t																	ui8RBits;
			/** G bit count. */
			uint8_t																	ui8GBits;
			/** B bit count. */
			uint8_t																	ui8BBits;
			/** A bit count. */
			uint8_t																	ui8ABits;
			/** R shift count. */
			uint8_t																	ui8RShift;
			/** G shift count. */
			uint8_t																	ui8GShift;
			/** B shift count. */
			uint8_t																	ui8BShift;
			/** A shift count. */
			uint8_t																	ui8AShift;
			/** Function to convert to RGBA64F. */
			PfToRgba64F																pfToRgba64F;
			/** Function to convert from RGBA64F to the internal OpenGL/Vulkan format. */
			PfFromRgba64F															pfFromRgba64F;
			/** A custom parameter that can be passed to conversion functions. */
			void *																	pvCustom;
		} * LPSL2_KTX_INTERNAL_FORMAT_DATA, * const LPCSL2_KTX_INTERNAL_FORMAT_DATA;

		/** An RGBA color component. */
		typedef struct SL2_RGBA {
			float																	fRgba[4];
		} * LPSL2_RGBA, * const LPCSL2_RGBA;

		/** An RGB color component. */
		typedef struct SL2_RGB {
			float																	fRgb[3];
		} * LPSL2_RGB, * const LPCSL2_RGB;

		/** An RGBA color component. */
		typedef struct SL2_RGBA64F {
			double																	dRgba[4];
		} * LPSL2_RGBA64F, * const LPCSL2_RGBA64F;

		/** An RGB color component. */
		typedef struct SL2_RGB64F {
			double																	fRgb[3];
		} * LPSL2_RGB64F, * const LPCSL2_RGB64F;

		/** An RGBA color component. */
		typedef struct SL2_RGBA_UNORM {
			uint8_t																	ui8Rgba[4];
		} * LPSL2_RGBA_UNORM, * const LPCSL2_RGBA_UNORM;

		/** An RGB color component. */
		typedef struct SL2_RGB_UNORM {
			uint8_t																	ui8Rgb[3];
		} * LPSL2_RGB_UNORM, * const LPCSL2_RGB_UNORM;

		/** An RGBA color component. */
		typedef struct SL2_RGBA16_UNORM {
			uint16_t																ui16Rgba[4];
		} * LPSL2_RGBA16_UNORM, * const LPCSL2_RGBA16_UNORM;

		/** An RGB color component. */
		typedef struct SL2_RGB16_UNORM {
			uint16_t																ui16Rgb[3];
		} * LPSL2_RGB16_UNORM, * const LPCSL2_RGB16_UNORM;

		/** An R5G6B5 color component. */
		typedef struct SL2_R5G6B5_PACKED {
			uint16_t																ui16R : 5;
			uint16_t																ui16G : 6;
			uint16_t																ui16B : 5;
		} * LPSL2_R5G6B5_PACKED, * const LPCSL2_R5G6B5_PACKED;

		/** An A1R5G5B5 color component. */
		typedef struct SL2_A1R5G6B5_PACKED {
			uint16_t																ui16A : 1;
			uint16_t																ui16R : 5;
			uint16_t																ui16G : 5;
			uint16_t																ui16B : 5;
		} * LPSL2_A1R5G6B5_PACKED, * const LPCSL2_A1R5G6B5_PACKED;


		/** Options for creating DXT file images. */
		typedef struct SL2_DXT_OPTIONS {
			/** Alpha cut-off for DXT1 images. */
			float																	fAlphaThresh;
			/** Red weight. */
			float																	fRedWeight;
			/** Green weight. */
			float																	fGreenWeight;
			/** Blue weight. */
			float																	fBlueWeight;
		} * LPSL2_DXT_OPTIONS, * const LPCSL2_DXT_OPTIONS;

		/** Thread data for converting blocks to DXTn. */
		typedef struct SL2_DXT_THREAD_DATA {
			/** The block X starting point in the source data. */
			uint32_t																ui32SrcX;
			/** The block Y starting point in the source data. */
			uint32_t																ui32SrcY;
			/** The block Z starting point in the source data. */
			uint32_t																ui32SrcZ;
			/** The source image. */
			const uint8_t *															pui8Src;
			/** Image width. */
			uint32_t																ui32Width;
			/** Image height. */
			uint32_t																ui32Height;
			/** Image depth. */
			uint32_t																ui32Depth;
			/** Destination of the compressioned chunk. */
			uint8_t *																pui8Dest;
			/** Pixel format. */
			//SL2_PIXEL_FORMAT														pfFormat;
			/** Treat BC5 as LATC2. */
			bool																	bLatc;
			/** Indicates the thread has finished. */
			std::atomic<bool>														bDone;
			/** Threading events. */
			CEvent																	eEvent;
			/** The conversion options. */
			SL2_DXT_OPTIONS *														pdoOptions;
			/** The format data. */
			const SL2_KTX_INTERNAL_FORMAT_DATA *									pkifdFormatData;
		} * LPSL2_DXT_THREAD_DATA, * const LPCSL2_DXT_THREAD_DATA;

		/** Luma coefficients. */
		struct SL2_LUMA {
			double																	dRgb[3];						/**< The luma coefficients. */
		};


		// == Functions.
		/**
		 * Finds format data given its Vulkan format identifier.
		 * 
		 * \param _vfFormat The format to find.
		 * \return Returns the matching SL2_KTX_INTERNAL_FORMAT_DATA data, or nullptr.
		 **/
		static const SL2_KTX_INTERNAL_FORMAT_DATA *									FindFormatDataByVulkan( SL2_VKFORMAT _vfFormat );

		/**
		 * Finds format data given its Vulkan format string.
		 * 
		 * \param _pcFormat The format to find by name.
		 * \return Returns the matching SL2_KTX_INTERNAL_FORMAT_DATA data, or nullptr.
		 **/
		static const SL2_KTX_INTERNAL_FORMAT_DATA *									FindFormatDataByVulkan( const char * _pcFormat );

		/**
		 * Finds format data given its Direct3D 12 format identifier.
		 * 
		 * \param _dfFormat The format to find.
		 * \return Returns the matching SL2_KTX_INTERNAL_FORMAT_DATA data, or nullptr.
		 **/
		static const SL2_KTX_INTERNAL_FORMAT_DATA *									FindFormatDataByDx( SL2_DXGI_FORMAT _dfFormat );

		/**
		 * Finds format data given its Direct3D 12 format string.
		 * 
		 * \param _pcFormat The format to find by name.
		 * \return Returns the matching SL2_KTX_INTERNAL_FORMAT_DATA data, or nullptr.
		 **/
		static const SL2_KTX_INTERNAL_FORMAT_DATA *									FindFormatDataByDx( const char * _pcFormat );

		/**
		 * Finds format data given its OpenGL format identifier.
		 * 
		 * \param _kifFormat The format to find.
		 * \return Returns the matching SL2_KTX_INTERNAL_FORMAT_DATA data, or nullptr.
		 **/
		static const SL2_KTX_INTERNAL_FORMAT_DATA *									FindFormatDataByOgl( SL2_KTX_INTERNAL_FORMAT _kifFormat );

		/**
		 * Finds format data given its OpenGL format string.
		 * 
		 * \param _pcFormat The format to find by name.
		 * \return Returns the matching SL2_KTX_INTERNAL_FORMAT_DATA data, or nullptr.
		 **/
		static const SL2_KTX_INTERNAL_FORMAT_DATA *									FindFormatDataByOgl( const char * _pcFormat );

		/**
		 * Finds format data given its Metal format identifier.
		 * 
		 * \param _mpfFormat The format to find.
		 * \return Returns the matching SL2_KTX_INTERNAL_FORMAT_DATA data, or nullptr.
		 **/
		static const SL2_KTX_INTERNAL_FORMAT_DATA *									FindFormatDataByMetal( SL2_MTLPIXELFORMAT _mpfFormat );

		/**
		 * Finds format data given its Metal format string.
		 * 
		 * \param _pcFormat The format to find by name.
		 * \return Returns the matching SL2_KTX_INTERNAL_FORMAT_DATA data, or nullptr.
		 **/
		static const SL2_KTX_INTERNAL_FORMAT_DATA *									FindFormatDataByMetal( const char * _pcFormat );

		/**
		 * Gets the size, in bytes, of a texel format.
		 *
		 * \param _pkifFormat The texel format.
		 * \return Returns the size of the given format in bytes.
		 */
		static inline uint32_t SL2_FASTCALL											GetFormatSize( const SL2_KTX_INTERNAL_FORMAT_DATA * _pkifFormat );

		/**
		 * Gets the size, in bytes, of a texel format.
		 *
		 * \param _pkifFormat The texel format.
		 * \param _ui32Width The width of the image.
		 * \param _ui32Height The height of the image.
		 * \param _ui32Depth The depth of the image.
		 * \return Returns the size of the given format in bytes.
		 */
		static inline uint32_t SL2_FASTCALL											GetFormatSize( const SL2_KTX_INTERNAL_FORMAT_DATA * _pkifFormat, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth );

		/**
		 * Gets the size, in bytes, of a texel format.
		 *
		 * \param _vfFormat The texel format.
		 * \param _ui32Width The width of the image.
		 * \param _ui32Height The height of the image.
		 * \param _ui32Depth The depth of the image.
		 * \return Returns the size of the given format in bytes.
		 */
		static inline uint32_t SL2_FASTCALL											GetFormatSize( SL2_VKFORMAT _vfFormat, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth ) { return GetFormatSize( FindFormatDataByVulkan( _vfFormat ), _ui32Width, _ui32Height, _ui32Depth ); }

		/**
		 * Gets the size, in bytes, of a texel format.
		 *
		 * \param _dfFormat The texel format.
		 * \param _ui32Width The width of the image.
		 * \param _ui32Height The height of the image.
		 * \param _ui32Depth The depth of the image.
		 * \return Returns the size of the given format in bytes.
		 */
		static inline uint32_t SL2_FASTCALL											GetFormatSize( SL2_DXGI_FORMAT _dfFormat, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth ) { return GetFormatSize( FindFormatDataByDx( _dfFormat ), _ui32Width, _ui32Height, _ui32Depth ); }

		/**
		 * Gets the size, in bytes, of a texel format.
		 *
		 * \param _kifFormat The texel format.
		 * \param _ui32Width The width of the image.
		 * \param _ui32Height The height of the image.
		 * \param _ui32Depth The depth of the image.
		 * \return Returns the size of the given format in bytes.
		 */
		static inline uint32_t SL2_FASTCALL											GetFormatSize( SL2_KTX_INTERNAL_FORMAT _kifFormat, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth ) { return GetFormatSize( FindFormatDataByOgl( _kifFormat ), _ui32Width, _ui32Height, _ui32Depth ); }

		/**
		 * Gets the size, in bytes, of a texel format.
		 *
		 * \param _mpfFormat The texel format.
		 * \param _ui32Width The width of the image.
		 * \param _ui32Height The height of the image.
		 * \param _ui32Depth The depth of the image.
		 * \return Returns the size of the given format in bytes.
		 */
		static inline uint32_t SL2_FASTCALL											GetFormatSize( SL2_MTLPIXELFORMAT _mpfFormat, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth ) { return GetFormatSize( FindFormatDataByMetal( _mpfFormat ), _ui32Width, _ui32Height, _ui32Depth ); }

		/**
		 * Gets the size, in bytes, of a texel format.
		 *
		 * \param _vfFormat The texel format.
		 * \return Returns the size of the given format in bytes.
		 */
		static inline uint32_t SL2_FASTCALL											GetFormatSize( SL2_VKFORMAT _vfFormat ) { return GetFormatSize( FindFormatDataByVulkan( _vfFormat ) ); }

		/**
		 * Gets the size, in bytes, of a texel format.
		 *
		 * \param _vfFormat The texel format.
		 * \return Returns the size of the given format in bytes.
		 */
		static inline uint32_t SL2_FASTCALL											GetFormatSize( SL2_DXGI_FORMAT _dfFormat ) { return GetFormatSize( FindFormatDataByDx( _dfFormat ) ); }

		/**
		 * Gets the size, in bytes, of a texel format.
		 *
		 * \param _kifFormat The texel format.
		 * \return Returns the size of the given format in bytes.
		 */
		static inline uint32_t SL2_FASTCALL											GetFormatSize( SL2_KTX_INTERNAL_FORMAT _kifFormat ) { return GetFormatSize( FindFormatDataByOgl( _kifFormat ) ); }

		/**
		 * Gets the size, in bytes, of a texel format.
		 *
		 * \param _mpfFormat The texel format.
		 * \return Returns the size of the given format in bytes.
		 */
		static inline uint32_t SL2_FASTCALL											GetFormatSize( SL2_MTLPIXELFORMAT _mpfFormat ) { return GetFormatSize( FindFormatDataByMetal( _mpfFormat ) ); }

		/**
		 * Gets the width of a row of texels in bytes.
		 *
		 * \param _vfFormat Format of the texel data.
		 * \param _ui32Total Number of texels in a row.
		 * \return Returns the number of bytes in a row of tightly packed texel data.
		 */
		static inline uint32_t SL2_FASTCALL											GetRowSize( SL2_VKFORMAT _vfFormat, uint32_t _ui32Total ) {
			return GetFormatSize( _vfFormat, _ui32Total, 1, 1 );
		}

		/**
		 * Gets the width of a row of texels in bytes.
		 *
		 * \param _dfFormat Format of the texel data.
		 * \param _ui32Total Number of texels in a row.
		 * \return Returns the number of bytes in a row of tightly packed texel data.
		 */
		static inline uint32_t SL2_FASTCALL											GetRowSize( SL2_DXGI_FORMAT _dfFormat, uint32_t _ui32Total ) {
			return GetFormatSize( _dfFormat, _ui32Total, 1, 1 );
		}

		/**
		 * Gets the width of a row of texels in bytes.
		 *
		 * \param _kifFormat Format of the texel data.
		 * \param _ui32Total Number of texels in a row.
		 * \return Returns the number of bytes in a row of tightly packed texel data.
		 */
		static inline uint32_t SL2_FASTCALL											GetRowSize( SL2_KTX_INTERNAL_FORMAT _kifFormat, uint32_t _ui32Total ) {
			return GetFormatSize( _kifFormat, _ui32Total, 1, 1 );
		}

		/**
		 * Gets the width of a row of texels in bytes.
		 *
		 * \param _mpfFormat Format of the texel data.
		 * \param _ui32Total Number of texels in a row.
		 * \return Returns the number of bytes in a row of tightly packed texel data.
		 */
		static inline uint32_t SL2_FASTCALL											GetRowSize( SL2_MTLPIXELFORMAT _mpfFormat, uint32_t _ui32Total ) {
			return GetFormatSize( _mpfFormat, _ui32Total, 1, 1 );
		}

		/**
		 * Given a set of formats, finds the one among them that is the best fit for the given format.
		 * 
		 * \param _pkifFormat The input format.
		 * \param _ppkifFormats The array of formats.
		 * \param _sTotal The total number of formats to which _pkifFormats points.
		 * \param _pfScore AN optional pointer to a float that can receive the score for the return format.
		 * \return Returns the format among _pkifFormats that best fits _pkifFormat.  Can return nullptr in case of error.
		 **/
		static const SL2_KTX_INTERNAL_FORMAT_DATA *									FindBestFormat( const SL2_KTX_INTERNAL_FORMAT_DATA * _pkifFormat,
			const SL2_KTX_INTERNAL_FORMAT_DATA ** _ppkifFormats, size_t _sTotal, float * _pfScore = nullptr );

		/**
		 * Gets the score for how well _pkifTest matches _pkifFormat as a possible conversion target format.  IE how well _pkifFormat can be converted to _pkifTest.
		 * 
		 * \param _pkifFormat The source format.
		 * \param _pkifTest The potential destination format.
		 * \return Returns a score indicating how well _pkifFormat can be converted to _pkifTest.  Higher is better.
		 **/
		static float																ScoreFormat( const SL2_KTX_INTERNAL_FORMAT_DATA * _pkifFormat,
			const SL2_KTX_INTERNAL_FORMAT_DATA * _pkifTest );

		/**
		 * Gets the number of channels on the given format.
		 * 
		 * \param _pkifFormat The format whose channel count is to be obtained.
		 * \return Returns the number of channels on _pkifFormat.
		 **/
		static uint32_t																CountChannels( const SL2_KTX_INTERNAL_FORMAT_DATA * _pkifFormat );


	protected :
		// == Types.
		/** A block of texels for DDS encoding. */
		typedef union SL2_BLOCK {
			struct SL2_COLOR {
				double																dR, dG, dB, dA;
			}																		s;
			double																	dValues[4];


			// == Operators.
			/**
			 * The less-than operator.
			 *
			 * \param _bOther The object against which to test.
			 * \return Returns true if this object is less than the given object.
			 */
			inline bool 															operator < ( const SL2_BLOCK &_bOther ) const;

			/**
			 * The equality operator.
			 *
			 * \param _bOther The object against which to test.
			 * \return Returns true if this object is equal to the given object.
			 */
			inline bool 															operator == ( const SL2_BLOCK &_bOther ) const;

			/**
			 * The inequality operator.
			 *
			 * \param _bOther The object against which to test.
			 * \return Returns true if this object is not equal to the given object.
			 */
			inline bool 															operator != ( const SL2_BLOCK &_bOther ) const;
		} * LPSL2_BLOCK, * const LPCSL2_BLOCK;


		// == Members.
		/** The data for internal formats. */
		static const SL2_KTX_INTERNAL_FORMAT_DATA									m_kifdInternalFormats[];
		/** Whether to use NVIDA's decoding of block formats or not. */
		static bool																	m_bUseNVidiaDecode;
		/** The luma coefficients for each standard. */
		static const SL2_LUMA														m_lLumaCoeffs[SL2_LS_TOTAL];
		/** The current luma coefficients. */
		static SL2_LUMA_STANDARDS													m_lsCurStandard;


		// == Functions.
		/**
		 * Generic conversion of a single integer component to a float (normalized).
		 *
		 * \param _ui64Value The RGBA texel.
		 * \param _dDefault The default value to return if there are no bits for the component within _ui64Value (_uBits is 0).
		 * \return Returns the component extracted from _ui64Value and converted to a double.
		 */
		template <unsigned _uBits, unsigned _uShift, unsigned _uSigned, unsigned _bSrgb>
		static inline double 														StdIntComponentTo64F_Norm( uint64_t _ui64Value, double _dDefault ) {
			if constexpr ( _uBits != 0 ) {
				if constexpr ( _uSigned != 0 ) {
					constexpr uint64_t ui64Mask = ~0ULL >> (64U - _uBits);
					int64_t i64Texel = ((_ui64Value >> _uShift) & ui64Mask);
					// Sign-extend.
					i64Texel <<= 64U - _uBits;
					i64Texel >>= 64U - _uBits;
					// warning C4293: '<<': shift count negative or too big, undefined behavior
					//	_uBits can't be 0 so this warning is invalid.
					// warning C4723: potential divide by 0
					//	_uBits can't be 0 so this warning is invalid.
					double dFinal = CUtilities::Clamp<double>( i64Texel / static_cast<double>((1ULL << (_uBits - 1ULL)) - 1ULL), -1.0, 1.0 );
					return _bSrgb ? CUtilities::SRgbToLinear( dFinal ) : dFinal;
				}
				else {
					constexpr uint64_t ui64Max = ~0ULL >> (64U - _uBits);
					double dFinal = ((_ui64Value >> _uShift) & ui64Max) / static_cast<double>(ui64Max);
					return _bSrgb ? CUtilities::SRgbToLinear( dFinal ) : dFinal;
				}
			}
			else { return _dDefault; }
		}

		/**
		 * Generic conversion of a single floating-point value to a single normalized RGBA component encoded inside a uint64_t.  The appropriate bits
		 *	inside the uint64_t value are cleared and then overwritten, modifying only the bits that correspend to the texel component being
		 *	updated.
		 *
		 * \param _dValue The value to convert.
		 * \param _ui64Value The RGBA texel to update.
		 */
		template <unsigned _uBits, unsigned _uShift, unsigned _uSigned, unsigned _bSrgb>
		static inline void 															Std64FToIntComponent_Norm( double _dValue, uint64_t &_ui64Value ) {
			// Only do something if there are actual bits to modify.
			if constexpr ( _uBits != 0 ) {
				if constexpr ( _bSrgb != 0 ) {
					_dValue = CUtilities::LinearToSRgb( _dValue );
				}
				// Clear the target bits.
				constexpr uint64_t ui64Mask = ~0ULL >> (64U - _uBits);
				_ui64Value = _ui64Value & ~(ui64Mask << _uShift);
				if constexpr ( _uSigned != 0 ) {
					int64_t i64Val = static_cast<int64_t>(std::round( CUtilities::Clamp( _dValue, -1.0, 1.0 ) * static_cast<double>((1ULL << (_uBits - 1ULL)) - 1ULL) ));
					_ui64Value |= (i64Val & ui64Mask) << _uShift;
				}
				else {
					uint64_t ui64Val = static_cast<uint64_t>(std::round( CUtilities::Clamp( _dValue, 0.0, 1.0 ) * ui64Mask ));
					_ui64Value |= (ui64Val & ui64Mask) << _uShift;
				}
			}
		}

		/**
		 * Generic conversion of a single integer component to a double (not normalized).
		 *
		 * \param _ui64Value The RGBA texel.
		 * \param _dDefault The default value to return if there are no bits for the component within _ui64Value (_uBits is 0).
		 * \return Returns the component extracted from _ui64Value and converted to a double.
		 */
		template <unsigned _uBits, unsigned _uShift, unsigned _uSigned>
		static inline double 														StdIntComponentTo64F( uint64_t _ui64Value, double _dDefault ) {
			if constexpr ( _uBits != 0 ) {
				if constexpr ( _uSigned != 0 ) {
					constexpr uint64_t ui64Mask = ~0ULL >> (64U - _uBits);
					int64_t i64Texel = ((_ui64Value >> _uShift) & ui64Mask);
					// Sign-extend.
					i64Texel <<= 64U - _uBits;
					i64Texel >>= 64U - _uBits;
					// warning C4293: '<<': shift count negative or too big, undefined behavior
					//	_uBits can't be 0 so this warning is invalid.
					// warning C4723: potential divide by 0
					//	_uBits can't be 0 so this warning is invalid.
					return static_cast<double>(i64Texel) / (ui64Mask >> 1);
				}
				else {
					constexpr uint64_t ui64Max = ~0ULL >> (64U - _uBits);
					uint64_t ui64Multiplicand = ui64Max;
					if constexpr ( _uBits > DBL_MANT_DIG ) {
						ui64Multiplicand = ~((1ULL << (_uBits - DBL_MANT_DIG)) - 1ULL);
					}
					return static_cast<double>((_ui64Value >> _uShift) & ui64Multiplicand) / ui64Multiplicand;
				}
			}
			else { return _dDefault; }
		}

		/**
		 * Generic conversion of a single floating-point value to a single non-normalized RGBA component encoded inside a uint64_t.  The appropriate bits
		 *	inside the uint64_t value are cleared and then overwritten, modifying only the bits that correspend to the texel component being
		 *	updated.
		 *
		 * \param _dValue The value to convert.
		 * \param _ui64Value The RGBA texel to update.
		 */
		template <unsigned _uBits, unsigned _uShift, unsigned _uSigned>
		static inline void 															Std64FToIntComponent( double _dValue, uint64_t &_ui64Value ) {
			// Only do something if there are actual bits to modify.
			if constexpr ( _uBits != 0 ) {
				// Clear the target bits.
				constexpr uint64_t ui64Mask = ~0ULL >> (64U - _uBits);
				_ui64Value = _ui64Value & ~(ui64Mask << _uShift);
				if constexpr ( _uSigned != 0 ) {
					const double dPow = std::pow( 2.0, _uBits - 1.0 );
					int64_t i64Val = static_cast<int64_t>(std::round( CUtilities::Clamp( _dValue * (ui64Mask >> 1), -dPow, dPow - 1.0 ) ));
					_ui64Value |= (i64Val & ui64Mask) << _uShift;
				}
				else {
					uint64_t ui64Multiplicand = ui64Mask;
					if constexpr ( _uBits > DBL_MANT_DIG ) {
						ui64Multiplicand = ~((1ULL << (_uBits - DBL_MANT_DIG)) - 1ULL);
					}
					uint64_t ui64Val =  CUtilities::Clamp( static_cast<uint64_t>(std::round( _dValue * ui64Multiplicand )), 0ULL, ui64Mask );
					_ui64Value |= (ui64Val & ui64Mask) << _uShift;
				}
			}
		}

		/**
		 * Returns the maximum of 3 components.
		 *
		 * \param _dR The R component.
		 * \param _dG The G component.
		 * \param _dB The B component.
		 * \return Returns the maximum of 3 components.
		 */
		static inline double 														Max( double _dR, double _dG, double _dB ) {
			if ( _dR > _dG ) {
				if ( _dR > _dB ) { return _dR; }
				else { return _dB; }
			}
			else {
				if ( _dG > _dB ) { return _dG; }
				else { return _dB; }
			}
		}

		/**
		 * Clamps a value within RGB9_E5 range
		 *
		 * \param _dVal The value to clamp.
		 * \return Returns _dVal clamped between 0.0f and SL2_MAX_RGB9E5.
		 */
		static inline double 														ClampRangeRgb9e5( double _dVal ) {
			return CUtilities::Clamp( _dVal, 0.0, SL2_MAX_RGB9E5 );
		}

		/**
		 * Gets the biased exponent from a floating-point number.
		 *
		 * \param _fVal The value whose exponent is to be retrieved.
		 * \return Returns the biased exponent from a floating-point number.
		 */
		static inline int32_t 														FloorLog2( float _fVal ) {
			struct SL2_FLOAT {
				uint32_t ui32Mantissa : 23;
				uint32_t ui32BiasedExponent : 8;
				uint32_t ui32Negative : 1;
			};
			union SL2_FLOAT_754 {
				SL2_FLOAT	fField;
				float		fValue;
			};
			SL2_FLOAT_754 fFTmp;

			fFTmp.fValue = _fVal;
			return (fFTmp.fField.ui32BiasedExponent - 127);
		}

		/**
		 * Returns the size, in pixels, of a block of a DDS file.
		 *
		 * \param _ifdFormat The DXT format whose block size is to be obtained.
		 * \return Returns the size, in pixels, of a block of a DDS file.
		 */
		static uint32_t																DxtBlockSize( const SL2_KTX_INTERNAL_FORMAT_DATA &_ifdFormat );

		/**
		 * Converts a 16-bit R5G6B5 end point into an RGBA64F color value.
		 *
		 * \param _ui16Point The end point to convert.
		 * \param _dPalette The output for the converted color.
		 */
		template <unsigned _bSrgb>
		static inline void 															Rgb565ToRgbaF64( uint16_t _ui16Point, SL2_RGBA64F &_dPalette );

		/**
		 * Decodes a single block of DXT1.
		 *
		 * \param _ui64Block The block to decode.
		 * \param _prPalette The created palette (contains 4 entries).
		 */
		template <unsigned _bSrgb>
		static void 																DecodeDXT1( uint64_t _ui64Block, SL2_RGBA64F * _prPalette );

		/**
		 * Decodes a single block of DXT3.
		 *
		 * \param _ui64Block The block to decode.
		 * \param _prPalette The created palette (contains 4 entries).
		 */
		template <unsigned _bSrgb>
		static void 																DecodeDXT3( uint64_t _ui64Block, SL2_RGBA64F * _prPalette );

		/**
		 * Decodes a single block of DXT3 alpha.
		 *
		 * \param _ui64Block The block to decode.
		 * \param _pfPalette The created palette (contains 16 entries).
		 */
		static void 																DecodeDXT3_Alpha( uint64_t _ui64Block, float * _pfPalette );

		/**
		 * Decodes a single block of BC4U.
		 *
		 * \param _ui64Block The block to decode.
		 * \param _pfPalette The created palette (contains 8 entries).
		 */
		static void 																DecodeBC4U( uint64_t _ui64Block, float * _pfPalette );

		/**
		 * Decodes a single block of BC4S.
		 *
		 * \param _ui64Block The block to decode.
		 * \param _pfPalette The created palette (contains 8 entries).
		 */
		static void 																DecodeBC4S( uint64_t _ui64Block, float * _pfPalette );

		/**
		 * Gets the indices from a DXT1 block. 
		 *
		 * \param _ui64Block The block to decode.
		 * \param _pui8Indices The 16 indices as extracted from the block.
		 */
		static void 																Dxt1Indices( uint64_t _ui64Block, uint8_t * _pui8Indices );

		/**
		 * Gets the indices from a BC4 block. 
		 *
		 * \param _ui64Block The block to decode.
		 * \param _pui8Indices The 16 indices as extracted from the block.
		 */
		static void 																Bc4Indices( uint64_t _ui64Block, uint8_t * _pui8Indices );

		/**
		 * Converts a single RGB9_E5 texel into an RGBA64F texel.
		 *
		 * \param _ui32R The RGB9_E5 R component.
		 * \param _ui32G The RGB9_E5 G component.
		 * \param _ui32B The RGB9_E5 B component.
		 * \param _ui32E The RGB9_E5 E component.
		 * \param _pdDst The destination floats for decoding.
		 */
		static inline void 															DecodeRgb9_E5( uint32_t _ui32R, uint32_t _ui32G, uint32_t _ui32B, uint32_t _ui32E, double * _pdDst ) {
			int32_t i32Exp = _ui32E - SL2_RGB9E5_EXP_BIAS - SL2_RGB9E5_MANTISSA_BITS;
			double dScale = std::pow( 2.0, double( i32Exp ) );

			_pdDst[SL2_PC_R] = _ui32R * dScale;
			_pdDst[SL2_PC_G] = _ui32G * dScale;
			_pdDst[SL2_PC_B] = _ui32B * dScale;
			_pdDst[SL2_PC_A] = 1.0;
		}

		/**
		 * Converts a single RGBA64F texel to an RGB9_E5 texel.
		 *
		 * \param _ui32Rgb9E5 The output texel encoded in a uint32_t value.
		 * \param _pfSrc The source floats.
		 */
		static inline void 															EncodeRgb9_E5( uint32_t &_ui32Rgb9E5, const double * _pfSrc ) {
			double dR = ClampRangeRgb9e5( _pfSrc[SL2_PC_R] );
			double dG = ClampRangeRgb9e5( _pfSrc[SL2_PC_G] );
			double dB = ClampRangeRgb9e5( _pfSrc[SL2_PC_B] );
			double dMax = Max( dR, dG, dB );
			int32_t i32ExpShared = static_cast<int32_t>(CUtilities::Max( -SL2_RGB9E5_EXP_BIAS - 1, FloorLog2( static_cast<float>(dMax) ) ) + 1 + SL2_RGB9E5_EXP_BIAS);
			double fDenom = std::pow( 2.0, double( i32ExpShared - SL2_RGB9E5_EXP_BIAS - SL2_RGB9E5_MANTISSA_BITS ) );

			int32_t i32MaxM = static_cast<int32_t>(std::floor( dMax / fDenom + 0.5 ));
			if ( i32MaxM == SL2_MAX_RGB9E5_MANTISSA + 1 ) {
				fDenom *= 2.0;
				++i32ExpShared;
			}

			int32_t i32Rm = static_cast<int32_t>(std::floor( dR / fDenom + 0.5 ));
			int32_t i32Gm = static_cast<int32_t>(std::floor( dG / fDenom + 0.5 ));
			int32_t i32Bm = static_cast<int32_t>(std::floor( dB / fDenom + 0.5 ));

			struct SL2_RGB9E5 {
				uint32_t ui32R : SL2_RGB9E5_MANTISSA_BITS;
				uint32_t ui32G : SL2_RGB9E5_MANTISSA_BITS;
				uint32_t ui32B : SL2_RGB9E5_MANTISSA_BITS;
				uint32_t ui32E : SL2_RGB9E5_EXPONENT_BITS;
			};
			SL2_RGB9E5 * prDst = reinterpret_cast<SL2_RGB9E5 *>(&_ui32Rgb9E5);
			prDst->ui32R = i32Rm;
			prDst->ui32G = i32Gm;
			prDst->ui32B = i32Bm;
			prDst->ui32E = i32ExpShared;
		}

		/**
		 * Generic integer format -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
			unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
			unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
		static bool 																StdIntToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Generic RGBA64F -> integer format conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
			unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
			unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
		static bool 																StdIntFromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * 128-bit integer format -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
			unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
			unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
		static bool 																Int128ToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * RGBA64F -> 128-bit integer format conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
			unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
			unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
		static bool 																Int128FromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * 256-bit integer format -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
			unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
			unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
		static bool 																Int256ToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * RGBA64F -> 256-bit integer format conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
			unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
			unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
		static bool 																Int256FromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * float16 -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
			unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
			unsigned _uTexelSize>
		static bool 																F16ToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * RGBA64F -> float16 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
			unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
			unsigned _uTexelSize>
		static bool 																F16FromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * float32 -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
			unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
			unsigned _uTexelSize>
		static bool 																F32ToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * RGBA64F -> float32 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
			unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
			unsigned _uTexelSize>
		static bool 																F32FromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * float64 -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
			unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
			unsigned _uTexelSize>
		static bool 																F64ToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * RGBA64F -> float64 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
			unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
			unsigned _uTexelSize>
		static bool 																F64FromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * R11G11B10F -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static inline bool 															R11G11B10FToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * RGBA64F -> R11G11B10F conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static inline bool 															R11G11B10FFromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * RGB9E5 -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static inline bool 															RGB9E5ToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * RGBA64F -> RGB9E5 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static inline bool 															RGB9E5FromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Luminance/alpha format -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uLBits, unsigned _uABits,
			unsigned _uLShift, unsigned _uAShift,
			unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
		static bool 																LumAlphaToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Generic RGBA64F -> luminance/alpha format conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uLBits, unsigned _uABits,
			unsigned _uLShift, unsigned _uAShift,
			unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
		static bool 																LumAlphaFromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Luminance/alpha (floating-point) format -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uLBits, unsigned _uABits,
			unsigned _uLShift, unsigned _uAShift,
			unsigned _uTexelSize>
		static bool 																LumAlphaFToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Generic RGBA64F -> luminance/alpha (floating-point) format conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uLBits, unsigned _uABits,
			unsigned _uLShift, unsigned _uAShift,
			unsigned _uTexelSize>
		static bool 																LumAlphaFFromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Intensity format -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uIBits,
			unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bFloat>
		static bool 																IntensityToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Generic RGBA64F -> intensity format conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uIBits,
			unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bFloat>
		static bool 																IntensityFromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Depth-16 -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool 																Depth16ToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * RGBA64F -> Depth-16 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool 																Depth16FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Depth-24 -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool 																Depth24ToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * RGBA64F -> Depth-24 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool 																Depth24FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Depth-32 -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool 																Depth32ToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * RGBA64F -> Depth-32 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool 																Depth32FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Depth-32F -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool 																Depth32FToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * RGBA64F -> Depth-32F conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool 																Depth32FFromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Depth-24/Stencil-8 -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool 																Depth24S8ToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * RGBA64F -> Depth-24/Stencil-8 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool 																Depth24S8FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Depth-32F/Stencil-8 -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool 																Depth32FS8ToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * RGBA64F -> Depth-32F/Stencil-8 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool 																Depth32FS8FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Stencil-X -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template<typename _tType, unsigned _uBits>
		static bool 																StencilXToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * RGBA64F -> Stencil-X conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template<typename _tType, unsigned _uBits>
		static bool 																StencilXFromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );



		// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		// BC* FORMATS
		// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		/**
		 * Returns the total size of a compressed image given a factor and its width and height.
		 *
		 * \param _ui32Width Width in pixels.
		 * \param _ui32Height Height in pixels.
		 * \param _ui32Depth Unused.
		 * \param _ui32Factor Multiplier.
		 * \param _pvParms Unused.
		 * \return Returns the size of the compressed data.
		 */
		static uint32_t																GetCompressedSizeBc( uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, uint32_t _ui32Factor, const void * _pvParms );

		/**
		 * DXT1 -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb>
		static bool 																Dxt1ToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Generic RGBA64F -> DXT1 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _ui8DefaultAlphaThresh, unsigned _bSrgb>
		static bool 																Dxt1FromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * DXT2 -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb>
		static bool 																Dxt2ToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr ) {
			Dxt3ToRgba64F( _pui8Src, _pui8Dst, _ui32Width, _ui32Height, _ui32Depth, _pvParms );
		}

		/**
		 * Generic RGBA64F -> DXT2 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb>
		static bool 				Dxt2FromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * DXT3 -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb>
		static bool 				Dxt3ToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Generic RGBA64F -> DXT3 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb>
		static bool 				Dxt3FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * DXT4 -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb>
		static bool 				Dxt4ToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr ) {
			Dxt5ToRgba32F( _pui8Src, _pui8Dst, _ui32Width, _ui32Height, _ui32Depth, _pvParms );
		}

		/**
		 * Generic RGBA64F -> DXT4 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb>
		static bool 				Dxt4FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * DXT5 -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb>
		static bool 				Dxt5ToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Generic RGBA64F -> DXT5 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb>
		static bool 				Dxt5FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * BC4U -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb, unsigned _bLum>
		static bool 				Bc4uToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Generic RGBA64F -> BC4U conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb, unsigned _bLum>
		static bool 				Bc4uFromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * BC4S -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb, unsigned _bLum>
		static bool 				Bc4sToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Generic RGBA64F -> BC4S conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb, unsigned _bLum>
		static bool 				Bc4sFromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * BC5U -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb, unsigned _bLumAlpha>
		static bool 				Bc5uToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Generic RGBA64F -> BC5U conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb, unsigned _bLumAlpha>
		static bool 				Bc5uFromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * BC5S -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb, unsigned _bLumAlpha>
		static bool 				Bc5sToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Generic RGBA64F -> BC5S conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb, unsigned _bLumAlpha>
		static bool 				Bc5sFromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * BC6H -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb>
		static bool 				Bc6hToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Generic RGBA64F -> BC6H conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb>
		static bool 				Bc6hFromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * BC7U -> RGBA64F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA64F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb>
		static bool 				Bc7uToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Generic RGBA64F -> BC7U conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA64F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _bSrgb>
		static bool 				Bc7uFromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms = nullptr );

		/**
		 * Thread function for converting a block of texels to DXTn formats.
		 *
		 * \param _lpParameter The thread information, stored as a pointer to a SL2_DXT_THREAD_DATA structure.
		 * \return Returns 0.
		 */
		template <unsigned _bSrgb>
		static uint32_t				DxtThread( void * _lpParameter );
	};
	


	// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	// DEFINITIONS
	// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	// == Operators.
	/**
	 * The less-than operator.
	 *
	 * \param _bOther The object against which to test.
	 * \return Returns true if this object is less than the given object.
	 */
	inline bool CFormat::SL2_BLOCK::operator < ( const SL2_BLOCK &_bOther ) const {
		return dValues[0] < _bOther.dValues[0] && dValues[1] < _bOther.dValues[1] &&
			dValues[2] < _bOther.dValues[2] && dValues[3] < _bOther.dValues[3];
	}

	 /**
	 * The equality operator.
	 *
	 * \param _bOther The object against which to test.
	 * \return Returns true if this object is equal to the given object.
	 */
	inline bool CFormat::SL2_BLOCK::operator == ( const SL2_BLOCK &_bOther ) const {
		return dValues[0] == _bOther.dValues[0] && dValues[1] == _bOther.dValues[1] &&
			dValues[2] == _bOther.dValues[2] && dValues[3] == _bOther.dValues[3];
	}

	 /**
	 * The inequality operator.
	 *
	 * \param _bOther The object against which to test.
	 * \return Returns true if this object is not equal to the given object.
	 */
	inline bool CFormat::SL2_BLOCK::operator != ( const SL2_BLOCK &_bOther ) const {
		return dValues[0] != _bOther.dValues[0] || dValues[1] != _bOther.dValues[1] ||
			dValues[2] != _bOther.dValues[2] || dValues[3] != _bOther.dValues[3];
	}

	// == Functions.
	/**
	 * Gets the size, in bytes, of a texel format.
	 *
	 * \param _pkifFormat The texel format.
	 * \return Returns the size of the given format in bytes.
	 */
	inline uint32_t SL2_FASTCALL CFormat::GetFormatSize( const SL2_KTX_INTERNAL_FORMAT_DATA * _pkifFormat ) {
		if ( _pkifFormat ) {
			return GetFormatSize( _pkifFormat, _pkifFormat->ui32BlockWidth, _pkifFormat->ui32BlockHeight, _pkifFormat->ui32BlockDepth );
		}
		return 0;
	}

	/**
	 * Gets the size, in bytes, of a texel format.
	 *
	 * \param _pkifFormat The texel format.
	 * \param _ui32Width The width of the image.
	 * \param _ui32Height The height of the image.
	 * \param _ui32Depth The depth of the image.
	 * \return Returns the size of the given format in bytes.
	 */
	inline uint32_t SL2_FASTCALL CFormat::GetFormatSize( const SL2_KTX_INTERNAL_FORMAT_DATA * _pkifFormat, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth ) {
		if ( _pkifFormat ) {
			if ( _pkifFormat->pfCompSizeFunc ) {
				return _pkifFormat->pfCompSizeFunc( _ui32Width, _ui32Height, _ui32Depth, _pkifFormat->ui32BlockSizeInBits, _pkifFormat );
			}
			uint32_t ui32Row = (_pkifFormat->ui32BlockSizeInBits * _ui32Width) >> 3;
			return (SL2_ROUND_UP( ui32Row, 4ULL ) * _ui32Height * _ui32Depth);
		}
		return 0;
	}

	/**
	 * Converts a 16-bit R5G6B5 end point into an RGBA64F color value.
	 *
	 * \param _ui16Point The end point to convert.
	 * \param _dPalette The output for the converted color.
	 */
	template <unsigned _bSrgb>
	inline void CFormat::Rgb565ToRgbaF64( uint16_t _ui16Point, SL2_RGBA64F &_dPalette ) {
		const uint32_t ui32Mask5 = (1 << 5) - 1;
		const uint32_t ui32Mask6 = (1 << 6) - 1;
		if ( m_bUseNVidiaDecode ) {
			uint32_t uiR = _ui16Point >> 11;
			uint32_t uiG = ((_ui16Point >> 5) & ui32Mask6);
			uint32_t uiB = _ui16Point & ui32Mask5;

			_dPalette.dRgba[SL2_PC_B] = ((3 * uiB * 22) / 8) / 255.0;
			_dPalette.dRgba[SL2_PC_G] = ((uiG << 2) | (uiG >> 4)) / 255.0;
			_dPalette.dRgba[SL2_PC_R] = ((3 * uiR * 22) / 8) / 255.0;
		}
		else {
			_dPalette.dRgba[SL2_PC_R] = (_ui16Point >> 11) / static_cast<double>(ui32Mask5);
			_dPalette.dRgba[SL2_PC_G] = ((_ui16Point >> 5) & ui32Mask6) / static_cast<double>(ui32Mask6);
			_dPalette.dRgba[SL2_PC_B] = (_ui16Point & ui32Mask5) / static_cast<double>(ui32Mask5);
		}
		if constexpr ( _bSrgb != 0 ) {
			_dPalette.dRgba[SL2_PC_B] = CUtilities::SRgbToLinear( _dPalette.dRgba[SL2_PC_B] );
			_dPalette.dRgba[SL2_PC_G] = CUtilities::SRgbToLinear( _dPalette.dRgba[SL2_PC_G] );
			_dPalette.dRgba[SL2_PC_R] = CUtilities::SRgbToLinear( _dPalette.dRgba[SL2_PC_R] );
		}
		_dPalette.dRgba[SL2_PC_A] = 1.0;
	}

	/**
	 * Decodes a single block of DXT1.
	 *
	 * \param _ui64Block The block to decode.
	 * \param _prPalette The created palette (contains 4 entries).
	 */
	template <unsigned _bSrgb>
	void CFormat::DecodeDXT1( uint64_t _ui64Block, SL2_RGBA64F * _prPalette ) {
		uint16_t ui16Tmp0 = _ui64Block & 0xFFFF;
		uint16_t ui16Tmp1 = (_ui64Block >> 16) & 0xFFFF;
		Rgb565ToRgbaF64<false>( ui16Tmp0, _prPalette[0] );
		Rgb565ToRgbaF64<false>( ui16Tmp1, _prPalette[1] );

		if ( m_bUseNVidiaDecode ) {
			const uint32_t ui32Mask5 = (1 << 5) - 1;
			uint32_t uiR0 = ui16Tmp0 >> 11;
			uint32_t uiB0 = ui16Tmp0 & ui32Mask5;
			uint32_t uiR1 = ui16Tmp1 >> 11;
			uint32_t uiB1 = ui16Tmp1 & ui32Mask5;


			uint32_t uiFullG0 = static_cast<uint32_t>(std::round( _prPalette[0].dRgba[SL2_PC_G] * 255.0 ));
			uint32_t uiFullG1 = static_cast<uint32_t>(std::round( _prPalette[1].dRgba[SL2_PC_G] * 255.0 ));
			int32_t iDiff = uiFullG1 - uiFullG0;


			if ( ui16Tmp0 > ui16Tmp1 ) {
				_prPalette[2].dRgba[SL2_PC_R] = (((2 * uiR0 + uiR1) * 22) / 8) / 255.0;
				_prPalette[2].dRgba[SL2_PC_G] = ((256 * uiFullG0 + iDiff / 4 + 128 + iDiff * 80) / 256) / 255.0;
				_prPalette[2].dRgba[SL2_PC_B] = (((2 * uiB0 + uiB1) * 22) / 8) / 255.0;
				_prPalette[2].dRgba[SL2_PC_A] = 1.0;

				_prPalette[3].dRgba[SL2_PC_R] = (((2 * uiR1 + uiR0) * 22) / 8) / 255.0;
				_prPalette[3].dRgba[SL2_PC_G] = ((256 * uiFullG1 - iDiff / 4 + 128 - iDiff * 80) / 256) / 255.0;
				_prPalette[3].dRgba[SL2_PC_B] = (((2 * uiB1 + uiB0) * 22) / 8) / 255.0;
				_prPalette[3].dRgba[SL2_PC_A] = 1.0;
			}
			else {
				_prPalette[2].dRgba[SL2_PC_R] = (((uiR0 + uiR1) * 33) / 8) / 255.0;
				_prPalette[2].dRgba[SL2_PC_G] = ((256 * uiFullG0 + iDiff / 4 + 128 + iDiff * 128) / 256) / 255.0;
				_prPalette[2].dRgba[SL2_PC_B] = (((uiB0 + uiB1) * 33) / 8) / 255.0;
				_prPalette[2].dRgba[SL2_PC_A] = 1.0;

				_prPalette[3].dRgba[SL2_PC_R] = 0.0;
				_prPalette[3].dRgba[SL2_PC_G] = 0.0;
				_prPalette[3].dRgba[SL2_PC_B] = 0.0;
				_prPalette[3].dRgba[SL2_PC_A] = 0.0;
			}
		}
		else {

			if ( ui16Tmp0 > ui16Tmp1 ) {
				_prPalette[2].dRgba[SL2_PC_R] = (_prPalette[0].dRgba[SL2_PC_R] * 2.0f + _prPalette[1].dRgba[SL2_PC_R]) / 3.0f;
				_prPalette[2].dRgba[SL2_PC_G] = (_prPalette[0].dRgba[SL2_PC_G] * 2.0f + _prPalette[1].dRgba[SL2_PC_G]) / 3.0f;
				_prPalette[2].dRgba[SL2_PC_B] = (_prPalette[0].dRgba[SL2_PC_B] * 2.0f + _prPalette[1].dRgba[SL2_PC_B]) / 3.0f;
				_prPalette[2].dRgba[SL2_PC_A] = 1.0;

				_prPalette[3].dRgba[SL2_PC_R] = (_prPalette[0].dRgba[SL2_PC_R] + _prPalette[1].dRgba[SL2_PC_R] * 2.0f) / 3.0f;
				_prPalette[3].dRgba[SL2_PC_G] = (_prPalette[0].dRgba[SL2_PC_G] + _prPalette[1].dRgba[SL2_PC_G] * 2.0f) / 3.0f;
				_prPalette[3].dRgba[SL2_PC_B] = (_prPalette[0].dRgba[SL2_PC_B] + _prPalette[1].dRgba[SL2_PC_B] * 2.0f) / 3.0f;
				_prPalette[3].dRgba[SL2_PC_A] = 1.0;
			}
			else {
				_prPalette[2].dRgba[SL2_PC_R] = (_prPalette[0].dRgba[SL2_PC_R] + _prPalette[1].dRgba[SL2_PC_R]) * 0.5f;
				_prPalette[2].dRgba[SL2_PC_G] = (_prPalette[0].dRgba[SL2_PC_G] + _prPalette[1].dRgba[SL2_PC_G]) * 0.5f;
				_prPalette[2].dRgba[SL2_PC_B] = (_prPalette[0].dRgba[SL2_PC_B] + _prPalette[1].dRgba[SL2_PC_B]) * 0.5f;
				_prPalette[2].dRgba[SL2_PC_A] = 1.0;

				_prPalette[3].dRgba[SL2_PC_R] = 0.0;
				_prPalette[3].dRgba[SL2_PC_G] = 0.0;
				_prPalette[3].dRgba[SL2_PC_B] = 0.0;
				_prPalette[3].dRgba[SL2_PC_A] = 0.0;
			}
		}
		if constexpr ( _bSrgb != 0 ) {
			for ( uint32_t I = 0; I < 4; ++I ) {
				_prPalette[I].dRgba[SL2_PC_R] = CUtilities::SRgbToLinear( _prPalette[I].dRgba[SL2_PC_R] );
				_prPalette[I].dRgba[SL2_PC_G] = CUtilities::SRgbToLinear( _prPalette[I].dRgba[SL2_PC_G] );
				_prPalette[I].dRgba[SL2_PC_B] = CUtilities::SRgbToLinear( _prPalette[I].dRgba[SL2_PC_B] );
			}
		}
	}

	/**
	 * Decodes a single block of DXT3.
	 *
	 * \param _ui64Block The block to decode.
	 * \param _prPalette The created palette (contains 4 entries).
	 */
	template <unsigned _bSrgb>
	void CFormat::DecodeDXT3( uint64_t _ui64Block, SL2_RGBA64F * _prPalette ) {
		uint16_t ui16Tmp0 = _ui64Block & 0xFFFF;
		uint16_t ui16Tmp1 = (_ui64Block >> 16) & 0xFFFF;
		Rgb565ToRgbaF64<false>( ui16Tmp0, _prPalette[0] );
		Rgb565ToRgbaF64<false>( ui16Tmp1, _prPalette[1] );

		if ( m_bUseNVidiaDecode ) {
			const uint32_t ui32Mask5 = (1 << 5) - 1;
			uint32_t uiR0 = ui16Tmp0 >> 11;
			uint32_t uiB0 = ui16Tmp0 & ui32Mask5;
			uint32_t uiR1 = ui16Tmp1 >> 11;
			uint32_t uiB1 = ui16Tmp1 & ui32Mask5;


			uint32_t uiFullG0 = static_cast<uint32_t>(std::round( _prPalette[0].dRgba[SL2_PC_G] * 255.0 ));
			uint32_t uiFullG1 = static_cast<uint32_t>(std::round( _prPalette[1].dRgba[SL2_PC_G] * 255.0 ));
			int32_t iDiff = uiFullG1 - uiFullG0;


			_prPalette[2].dRgba[SL2_PC_R] = (((2 * uiR0 + uiR1) * 22) / 8) / 255.0;
			_prPalette[2].dRgba[SL2_PC_G] = ((256 * uiFullG0 + iDiff / 4 + 128 + iDiff * 80) / 256) / 255.0;
			_prPalette[2].dRgba[SL2_PC_B] = (((2 * uiB0 + uiB1) * 22) / 8) / 255.0;
			_prPalette[2].dRgba[SL2_PC_A] = 1.0;

			_prPalette[3].dRgba[SL2_PC_R] = (((2 * uiR1 + uiR0) * 22) / 8) / 255.0;
			_prPalette[3].dRgba[SL2_PC_G] = ((256 * uiFullG1 - iDiff / 4 + 128 - iDiff * 80) / 256) / 255.0;
			_prPalette[3].dRgba[SL2_PC_B] = (((2 * uiB1 + uiB0) * 22) / 8) / 255.0;
			_prPalette[3].dRgba[SL2_PC_A] = 1.0;
		}
		else {

			_prPalette[2].dRgba[SL2_PC_R] = (_prPalette[0].dRgba[SL2_PC_R] * 2.0 + _prPalette[1].dRgba[SL2_PC_R]) / 3.0;
			_prPalette[2].dRgba[SL2_PC_G] = (_prPalette[0].dRgba[SL2_PC_G] * 2.0 + _prPalette[1].dRgba[SL2_PC_G]) / 3.0;
			_prPalette[2].dRgba[SL2_PC_B] = (_prPalette[0].dRgba[SL2_PC_B] * 2.0 + _prPalette[1].dRgba[SL2_PC_B]) / 3.0;
			_prPalette[2].dRgba[SL2_PC_A] = 1.0;

			_prPalette[3].dRgba[SL2_PC_R] = (_prPalette[0].dRgba[SL2_PC_R] + _prPalette[1].dRgba[SL2_PC_R] * 2.0) / 3.0;
			_prPalette[3].dRgba[SL2_PC_G] = (_prPalette[0].dRgba[SL2_PC_G] + _prPalette[1].dRgba[SL2_PC_G] * 2.0) / 3.0;
			_prPalette[3].dRgba[SL2_PC_B] = (_prPalette[0].dRgba[SL2_PC_B] + _prPalette[1].dRgba[SL2_PC_B] * 2.0) / 3.0;
			_prPalette[3].dRgba[SL2_PC_A] = 1.0;
		}

		if constexpr ( _bSrgb != 0 ) {
			for ( uint32_t I = 0; I < 4; ++I ) {
				_prPalette[I].dRgba[SL2_PC_R] = CUtilities::SRgbToLinear( _prPalette[I].dRgba[SL2_PC_R] );
				_prPalette[I].dRgba[SL2_PC_G] = CUtilities::SRgbToLinear( _prPalette[I].dRgba[SL2_PC_G] );
				_prPalette[I].dRgba[SL2_PC_B] = CUtilities::SRgbToLinear( _prPalette[I].dRgba[SL2_PC_B] );
			}
		}
	}

	/**
	 * Generic integer format -> RGBA64F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA64F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
		unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
		unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
	bool CFormat::StdIntToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		const uint64_t ui64RowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = SL2_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					SL2_RGBA64F & rgbaThis = reinterpret_cast<SL2_RGBA64F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(SL2_RGBA64F)]);
					const uint64_t * pui64Src = reinterpret_cast<const uint64_t *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize]);
					rgbaThis.dRgba[SL2_PC_R] = _bNorm ? StdIntComponentTo64F_Norm<_uRBits, _uRShift, _bSigned, _bSrgb>( (*pui64Src), 0.0 ) : StdIntComponentTo64F<_uRBits, _uRShift, _bSigned>( (*pui64Src), 0.0 );
					rgbaThis.dRgba[SL2_PC_G] = _bNorm ? StdIntComponentTo64F_Norm<_uGBits, _uGShift, _bSigned, _bSrgb>( (*pui64Src), 0.0 ) : StdIntComponentTo64F<_uGBits, _uGShift, _bSigned>( (*pui64Src), 0.0 );
					rgbaThis.dRgba[SL2_PC_B] = _bNorm ? StdIntComponentTo64F_Norm<_uBBits, _uBShift, _bSigned, _bSrgb>( (*pui64Src), 0.0 ) : StdIntComponentTo64F<_uBBits, _uBShift, _bSigned>( (*pui64Src), 0.0 );
					rgbaThis.dRgba[SL2_PC_A] = _bNorm ? StdIntComponentTo64F_Norm<_uABits, _uAShift, _bSigned, false>( (*pui64Src), 1.0 ) : StdIntComponentTo64F<_uABits, _uAShift, _bSigned>( (*pui64Src), 1.0 );
				}
			}
		}
		return true;
	}

	/**
	 * Generic RGBA64F -> integer format conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA64F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
		unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
		unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
	bool CFormat::StdIntFromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		struct SL2_RGBA64F {
			double dRgba[4];
		};
		const uint64_t ui64SrcRowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = SL2_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;

		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const SL2_RGBA64F & rgbaThis = reinterpret_cast<const SL2_RGBA64F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(SL2_RGBA64F)]);
					uint64_t * pui64Dst = reinterpret_cast<uint64_t *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize]);
					if constexpr ( _bNorm ) { Std64FToIntComponent_Norm<_uRBits, _uRShift, _bSigned, _bSrgb>( rgbaThis.dRgba[SL2_PC_R], (*pui64Dst) ); }
					else { Std64FToIntComponent<_uRBits, _uRShift, _bSigned>( rgbaThis.dRgba[SL2_PC_R], (*pui64Dst) ); }
					if constexpr ( _bNorm ) { Std64FToIntComponent_Norm<_uGBits, _uGShift, _bSigned, _bSrgb>( rgbaThis.dRgba[SL2_PC_G], (*pui64Dst) ); }
					else { Std64FToIntComponent<_uGBits, _uGShift, _bSigned>( rgbaThis.dRgba[SL2_PC_G], (*pui64Dst) ); }
					if constexpr ( _bNorm ) { Std64FToIntComponent_Norm<_uBBits, _uBShift, _bSigned, _bSrgb>( rgbaThis.dRgba[SL2_PC_B], (*pui64Dst) ); }
					else { Std64FToIntComponent<_uBBits, _uBShift, _bSigned>( rgbaThis.dRgba[SL2_PC_B], (*pui64Dst) ); }
					if constexpr ( _bNorm ) { Std64FToIntComponent_Norm<_uABits, _uAShift, _bSigned, false>( rgbaThis.dRgba[SL2_PC_A], (*pui64Dst) ); }
					else { Std64FToIntComponent<_uABits, _uAShift, _bSigned>( rgbaThis.dRgba[SL2_PC_A], (*pui64Dst) ); }
				}
			}
		}
		return true;
	}

	/**
	 * 128-bit integer format -> RGBA64F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA64F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
		unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
		unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
	bool CFormat::Int128ToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		const uint64_t ui64RowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = SL2_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;

		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					SL2_RGBA64F & rgbaThis = reinterpret_cast<SL2_RGBA64F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(SL2_RGBA64F)]);
					const uint8_t * pui8Src = reinterpret_cast<const uint8_t *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize]);
					rgbaThis.dRgba[SL2_PC_R] = _bNorm ? StdIntComponentTo64F_Norm<_uRBits, 0, _bSigned, _bSrgb>( reinterpret_cast<const uint32_t &>(pui8Src[_uRShift/8]), 0.0 ) : StdIntComponentTo64F<_uRBits, 0, _bSigned>( reinterpret_cast<const uint32_t &>(pui8Src[_uRShift/8]), 0.0 );
					rgbaThis.dRgba[SL2_PC_G] = _bNorm ? StdIntComponentTo64F_Norm<_uGBits, 0, _bSigned, _bSrgb>( reinterpret_cast<const uint32_t &>(pui8Src[_uGShift/8]), 0.0 ) : StdIntComponentTo64F<_uGBits, 0, _bSigned>( reinterpret_cast<const uint32_t &>(pui8Src[_uGShift/8]), 0.0 );
					rgbaThis.dRgba[SL2_PC_B] = _bNorm ? StdIntComponentTo64F_Norm<_uBBits, 0, _bSigned, _bSrgb>( reinterpret_cast<const uint32_t &>(pui8Src[_uBShift/8]), 0.0 ) : StdIntComponentTo64F<_uBBits, 0, _bSigned>( reinterpret_cast<const uint32_t &>(pui8Src[_uBShift/8]), 0.0 );
					rgbaThis.dRgba[SL2_PC_A] = _bNorm ? StdIntComponentTo64F_Norm<_uABits, 0, _bSigned, false>( reinterpret_cast<const uint32_t &>(pui8Src[_uAShift/8]), 1.0 ) : StdIntComponentTo64F<_uABits, 0, _bSigned>( reinterpret_cast<const uint32_t &>(pui8Src[_uAShift/8]), 1.0 );
				}
			}
		}
		return true;
	}

	/**
	 * RGBA64F -> 128-bit integer format conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA64F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
		unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
		unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
	bool CFormat::Int128FromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		const uint64_t ui64SrcRowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = SL2_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const SL2_RGBA64F & rgbaThis = reinterpret_cast<const SL2_RGBA64F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(SL2_RGBA64F)]);
					uint8_t * pui8Dst = reinterpret_cast<uint8_t *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize]);

					if constexpr ( _bNorm ) { Std64FToIntComponent_Norm<_uRBits, 0, _bSigned, _bSrgb>( rgbaThis.dRgba[SL2_PC_R], reinterpret_cast<uint64_t &>(pui8Dst[_uRShift>>3]) ); }
					else { Std64FToIntComponent<_uRBits, 0, _bSigned>( rgbaThis.dRgba[SL2_PC_R], reinterpret_cast<uint64_t &>(pui8Dst[_uRShift>>3]) ); }
					if constexpr ( _bNorm ) { Std64FToIntComponent_Norm<_uGBits, 0, _bSigned, _bSrgb>( rgbaThis.dRgba[SL2_PC_G], reinterpret_cast<uint64_t &>(pui8Dst[_uGShift>>3]) ); }
					else { Std64FToIntComponent<_uGBits, 0, _bSigned>( rgbaThis.dRgba[SL2_PC_G], reinterpret_cast<uint64_t &>(pui8Dst[_uGShift>>3]) ); }
					if constexpr ( _bNorm ) { Std64FToIntComponent_Norm<_uBBits, 0, _bSigned, _bSrgb>( rgbaThis.dRgba[SL2_PC_B], reinterpret_cast<uint64_t &>(pui8Dst[_uBShift>>3]) ); }
					else { Std64FToIntComponent<_uBBits, 0, _bSigned>( rgbaThis.dRgba[SL2_PC_B], reinterpret_cast<uint64_t &>(pui8Dst[_uBShift>>3]) ); }
					if constexpr ( _bNorm ) { Std64FToIntComponent_Norm<_uABits, 0, _bSigned, false>( rgbaThis.dRgba[SL2_PC_A], reinterpret_cast<uint64_t &>(pui8Dst[_uAShift>>3]) ); }
					else { Std64FToIntComponent<_uABits, 0, _bSigned>( rgbaThis.dRgba[SL2_PC_A], reinterpret_cast<uint64_t &>(pui8Dst[_uAShift>>3]) ); }
				}
			}
		}
		return true;
	}

	/**
	 * 256-bit integer format -> RGBA64F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA64F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
		unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
		unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
	bool CFormat::Int256ToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms ) {
		const uint64_t ui64RowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = SL2_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;

		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					SL2_RGBA64F & rgbaThis = reinterpret_cast<SL2_RGBA64F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(SL2_RGBA64F)]);
					const uint8_t * pui8Src = reinterpret_cast<const uint8_t *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize]);
					rgbaThis.dRgba[SL2_PC_R] = _bNorm ? StdIntComponentTo64F_Norm<_uRBits, 0, _bSigned, _bSrgb>( reinterpret_cast<const uint64_t &>(pui8Src[_uRShift/8]), 0.0 ) : StdIntComponentTo64F<_uRBits, 0, _bSigned>( reinterpret_cast<const uint64_t &>(pui8Src[_uRShift/8]), 0.0 );
					rgbaThis.dRgba[SL2_PC_G] = _bNorm ? StdIntComponentTo64F_Norm<_uGBits, 0, _bSigned, _bSrgb>( reinterpret_cast<const uint64_t &>(pui8Src[_uGShift/8]), 0.0 ) : StdIntComponentTo64F<_uGBits, 0, _bSigned>( reinterpret_cast<const uint64_t &>(pui8Src[_uGShift/8]), 0.0 );
					rgbaThis.dRgba[SL2_PC_B] = _bNorm ? StdIntComponentTo64F_Norm<_uBBits, 0, _bSigned, _bSrgb>( reinterpret_cast<const uint64_t &>(pui8Src[_uBShift/8]), 0.0 ) : StdIntComponentTo64F<_uBBits, 0, _bSigned>( reinterpret_cast<const uint64_t &>(pui8Src[_uBShift/8]), 0.0 );
					rgbaThis.dRgba[SL2_PC_A] = _bNorm ? StdIntComponentTo64F_Norm<_uABits, 0, _bSigned, false>( reinterpret_cast<const uint64_t &>(pui8Src[_uAShift/8]), 1.0 ) : StdIntComponentTo64F<_uABits, 0, _bSigned>( reinterpret_cast<const uint64_t &>(pui8Src[_uAShift/8]), 1.0 );
				}
			}
		}
		return true;
	}

	/**
	 * RGBA64F -> 256-bit integer format conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA64F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
		unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
		unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
	bool CFormat::Int256FromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms ) {
		const uint64_t ui64SrcRowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = SL2_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const SL2_RGBA64F & rgbaThis = reinterpret_cast<const SL2_RGBA64F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(SL2_RGBA64F)]);
					uint8_t * pui8Dst = reinterpret_cast<uint8_t *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize]);

					if constexpr ( _bNorm ) { Std64FToIntComponent_Norm<_uRBits, 0, _bSigned, _bSrgb>( rgbaThis.dRgba[SL2_PC_R], reinterpret_cast<uint64_t &>(pui8Dst[_uRShift>>3]) ); }
					else { Std64FToIntComponent<_uRBits, 0, _bSigned>( rgbaThis.dRgba[SL2_PC_R], reinterpret_cast<uint64_t &>(pui8Dst[_uRShift>>3]) ); }
					if constexpr ( _bNorm ) { Std64FToIntComponent_Norm<_uGBits, 0, _bSigned, _bSrgb>( rgbaThis.dRgba[SL2_PC_G], reinterpret_cast<uint64_t &>(pui8Dst[_uGShift>>3]) ); }
					else { Std64FToIntComponent<_uGBits, 0, _bSigned>( rgbaThis.dRgba[SL2_PC_G], reinterpret_cast<uint64_t &>(pui8Dst[_uGShift>>3]) ); }
					if constexpr ( _bNorm ) { Std64FToIntComponent_Norm<_uBBits, 0, _bSigned, _bSrgb>( rgbaThis.dRgba[SL2_PC_B], reinterpret_cast<uint64_t &>(pui8Dst[_uBShift>>3]) ); }
					else { Std64FToIntComponent<_uBBits, 0, _bSigned>( rgbaThis.dRgba[SL2_PC_B], reinterpret_cast<uint64_t &>(pui8Dst[_uBShift>>3]) ); }
					if constexpr ( _bNorm ) { Std64FToIntComponent_Norm<_uABits, 0, _bSigned, false>( rgbaThis.dRgba[SL2_PC_A], reinterpret_cast<uint64_t &>(pui8Dst[_uAShift>>3]) ); }
					else { Std64FToIntComponent<_uABits, 0, _bSigned>( rgbaThis.dRgba[SL2_PC_A], reinterpret_cast<uint64_t &>(pui8Dst[_uAShift>>3]) ); }
				}
			}
		}
		return true;
	}

	/**
	 * float16 -> RGBA64F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA64F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
		unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
		unsigned _uTexelSize>
	bool CFormat::F16ToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		const uint64_t ui64RowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = SL2_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					SL2_RGBA64F & rgbaThis = reinterpret_cast<SL2_RGBA64F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(SL2_RGBA64F)]);
					const sl2::CFloat16 * pf16Src = reinterpret_cast<const sl2::CFloat16 *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize]);
					rgbaThis.dRgba[SL2_PC_R] = _uRBits ? static_cast<double>(pf16Src[_uRShift/16].Value()) : 0.0f;
					rgbaThis.dRgba[SL2_PC_G] = _uGBits ? static_cast<double>(pf16Src[_uGShift/16].Value()) : 0.0f;
					rgbaThis.dRgba[SL2_PC_B] = _uBBits ? static_cast<double>(pf16Src[_uBShift/16].Value()) : 0.0f;
					rgbaThis.dRgba[SL2_PC_A] = _uABits ? static_cast<double>(pf16Src[_uAShift/16].Value()) : 1.0f;
				}
			}
		}
		return true;
	}

	/**
	 * RGBA64F -> float16 conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA64F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
		unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
		unsigned _uTexelSize>
	bool CFormat::F16FromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		struct SL2_RGBA64F {
			double dRgba[4];
		};
		const uint64_t ui64SrcRowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = SL2_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const SL2_RGBA64F & rgbaThis = reinterpret_cast<const SL2_RGBA64F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(SL2_RGBA64F)]);
					sl2::CFloat16 * pf16Dst = reinterpret_cast<sl2::CFloat16 *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize]);
					if constexpr ( _uRBits ) { pf16Dst[_uRShift/16] = rgbaThis.dRgba[SL2_PC_R]; }
					if constexpr ( _uGBits ) { pf16Dst[_uGShift/16] = rgbaThis.dRgba[SL2_PC_G]; }
					if constexpr ( _uBBits ) { pf16Dst[_uBShift/16] = rgbaThis.dRgba[SL2_PC_B]; }
					if constexpr ( _uABits ) { pf16Dst[_uAShift/16] = rgbaThis.dRgba[SL2_PC_A]; }
				}
			}
		}
		return true;
	}

	/**
	 * float32 -> RGBA64F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA64F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
		unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
		unsigned _uTexelSize>
	bool CFormat::F32ToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		const uint64_t ui64RowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = SL2_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					SL2_RGBA64F & rgbaThis = reinterpret_cast<SL2_RGBA64F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(SL2_RGBA64F)]);
					const float * pf32Src = reinterpret_cast<const float *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize]);
					rgbaThis.dRgba[SL2_PC_R] = _uRBits ? pf32Src[_uRShift/32] : 0.0f;
					rgbaThis.dRgba[SL2_PC_G] = _uGBits ? pf32Src[_uGShift/32] : 0.0f;
					rgbaThis.dRgba[SL2_PC_B] = _uBBits ? pf32Src[_uBShift/32] : 0.0f;
					rgbaThis.dRgba[SL2_PC_A] = _uABits ? pf32Src[_uAShift/32] : 1.0f;
				}
			}
		}
		return true;
	}

	/**
	 * RGBA64F -> float32 conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA64F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
		unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
		unsigned _uTexelSize>
	bool CFormat::F32FromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		const uint64_t ui64SrcRowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = SL2_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const SL2_RGBA64F & rgbaThis = reinterpret_cast<const SL2_RGBA64F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(SL2_RGBA64F)]);
					float * pf32Dst = reinterpret_cast<float *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize]);
					if constexpr ( _uRBits ) { pf32Dst[_uRShift/32] = static_cast<float>(rgbaThis.dRgba[SL2_PC_R]); }
					if constexpr ( _uGBits ) { pf32Dst[_uGShift/32] = static_cast<float>(rgbaThis.dRgba[SL2_PC_G]); }
					if constexpr ( _uBBits ) { pf32Dst[_uBShift/32] = static_cast<float>(rgbaThis.dRgba[SL2_PC_B]); }
					if constexpr ( _uABits ) { pf32Dst[_uAShift/32] = static_cast<float>(rgbaThis.dRgba[SL2_PC_A]); }
				}
			}
		}
		return true;
	}

	/**
	 * float64 -> RGBA64F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA64F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
		unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
		unsigned _uTexelSize>
	bool CFormat::F64ToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		const uint64_t ui64RowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = SL2_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					SL2_RGBA64F & rgbaThis = reinterpret_cast<SL2_RGBA64F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(SL2_RGBA64F)]);
					const double * pf64Src = reinterpret_cast<const double *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize]);
					rgbaThis.dRgba[SL2_PC_R] = _uRBits ? pf64Src[_uRShift/64] : 0.0f;
					rgbaThis.dRgba[SL2_PC_G] = _uGBits ? pf64Src[_uGShift/64] : 0.0f;
					rgbaThis.dRgba[SL2_PC_B] = _uBBits ? pf64Src[_uBShift/64] : 0.0f;
					rgbaThis.dRgba[SL2_PC_A] = _uABits ? pf64Src[_uAShift/64] : 1.0f;
				}
			}
		}
		return true;
	}

	/**
	 * RGBA64F -> float64 conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA64F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
		unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
		unsigned _uTexelSize>
	bool CFormat::F64FromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		const uint64_t ui64SrcRowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = SL2_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const SL2_RGBA64F & rgbaThis = reinterpret_cast<const SL2_RGBA64F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(SL2_RGBA64F)]);
					double * pf64Dst = reinterpret_cast<double *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize]);
					if constexpr ( _uRBits ) { pf64Dst[_uRShift/64] = static_cast<float>(rgbaThis.dRgba[SL2_PC_R]); }
					if constexpr ( _uGBits ) { pf64Dst[_uGShift/64] = static_cast<float>(rgbaThis.dRgba[SL2_PC_G]); }
					if constexpr ( _uBBits ) { pf64Dst[_uBShift/64] = static_cast<float>(rgbaThis.dRgba[SL2_PC_B]); }
					if constexpr ( _uABits ) { pf64Dst[_uAShift/64] = static_cast<float>(rgbaThis.dRgba[SL2_PC_A]); }
				}
			}
		}
		return true;
	}

	/**
	 * R11G11B10F -> RGBA64F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA64F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	inline bool CFormat::R11G11B10FToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		struct SL2_R11G11B10F {
			uint32_t ui32R : 11;
			uint32_t ui32G : 11;
			uint32_t ui32B : 10;
		};
		const uint64_t ui64RowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = SL2_ROUND_UP( 4ULL * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					SL2_RGBA64F & rgbaThis = reinterpret_cast<SL2_RGBA64F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(SL2_RGBA64F)]);
					const SL2_R11G11B10F * prSrc = reinterpret_cast<const SL2_R11G11B10F *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*4ULL]);
					sl2::CFloatX fTemp;
					rgbaThis.dRgba[SL2_PC_R] = static_cast<double>(fTemp.CreateFromBits( prSrc->ui32R, SL2_FLOAT11 ).AsDouble());
					rgbaThis.dRgba[SL2_PC_G] = static_cast<double>(fTemp.CreateFromBits( prSrc->ui32G, SL2_FLOAT11 ).AsDouble());
					rgbaThis.dRgba[SL2_PC_B] = static_cast<double>(fTemp.CreateFromBits( prSrc->ui32B, SL2_FLOAT10 ).AsDouble());
					rgbaThis.dRgba[SL2_PC_A] = 1.0;
				}
			}
		}
		return true;
	}

	/**
	 * RGBA64F -> R11G11B10F conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA64F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	inline bool CFormat::R11G11B10FFromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		struct SL2_R11G11B10F {
			uint32_t ui32R : 11;
			uint32_t ui32G : 11;
			uint32_t ui32B : 10;
		};
		const uint64_t ui64SrcRowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = SL2_ROUND_UP( 4ULL * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const SL2_RGBA64F & rgbaThis = reinterpret_cast<const SL2_RGBA64F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(SL2_RGBA64F)]);
					SL2_R11G11B10F * prDst = reinterpret_cast<SL2_R11G11B10F *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*4ULL]);
					sl2::CFloatX fTemp;
					prDst->ui32R = fTemp.CreateFromDouble( rgbaThis.dRgba[SL2_PC_R], SL2_FLOAT11 ).AsUint64();
					prDst->ui32G = fTemp.CreateFromDouble( rgbaThis.dRgba[SL2_PC_G], SL2_FLOAT11 ).AsUint64();
					prDst->ui32B = fTemp.CreateFromDouble( rgbaThis.dRgba[SL2_PC_B], SL2_FLOAT10 ).AsUint64();
				}
			}
		}
		return true;
	}

	/**
	 * RGB9E5 -> RGBA64F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA64F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	inline bool CFormat::RGB9E5ToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		struct SL2_RGB9E5 {
			uint32_t ui32R : SL2_RGB9E5_MANTISSA_BITS;
			uint32_t ui32G : SL2_RGB9E5_MANTISSA_BITS;
			uint32_t ui32B : SL2_RGB9E5_MANTISSA_BITS;
			uint32_t ui32E : SL2_RGB9E5_EXPONENT_BITS;
		};
		const uint64_t ui64RowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = SL2_ROUND_UP( 4ULL * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					SL2_RGBA64F & rgbaThis = reinterpret_cast<SL2_RGBA64F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(SL2_RGBA64F)]);
					const SL2_RGB9E5 * prSrc = reinterpret_cast<const SL2_RGB9E5 *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*4ULL]);
					DecodeRgb9_E5( prSrc->ui32R, prSrc->ui32G, prSrc->ui32B, prSrc->ui32E, rgbaThis.dRgba );
				}
			}
		}
		return true;
	}

	/**
	 * RGBA64F -> RGB9E5 conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA64F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	inline bool CFormat::RGB9E5FromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		const uint64_t ui64SrcRowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = SL2_ROUND_UP( 4ULL * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const SL2_RGBA64F & rgbaThis = reinterpret_cast<const SL2_RGBA64F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(SL2_RGBA64F)]);
					uint32_t * pui32Dst = reinterpret_cast<uint32_t *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*4ULL]);
					EncodeRgb9_E5( (*pui32Dst), rgbaThis.dRgba );
				}
			}
		}
		return true;
	}

	/**
	 * Luminance/alpha format -> RGBA64F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA64F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uLBits, unsigned _uABits,
		unsigned _uLShift, unsigned _uAShift,
		unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
	bool CFormat::LumAlphaToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		const uint64_t ui64RowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = SL2_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					SL2_RGBA64F & rgbaThis = reinterpret_cast<SL2_RGBA64F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(SL2_RGBA64F)]);
					const uint64_t * pui64Src = reinterpret_cast<const uint64_t *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize]);
					double dLum = _bNorm ? StdIntComponentTo64F_Norm<_uLBits, _uLShift, _bSigned, _bSrgb>( (*pui64Src), 0.0 ) : StdIntComponentTo64F<_uLBits, _uLShift, _bSigned>( (*pui64Src), 0.0 );
					rgbaThis.dRgba[SL2_PC_R] = dLum / 1.0;
					rgbaThis.dRgba[SL2_PC_G] = dLum / 1.0;
					rgbaThis.dRgba[SL2_PC_B] = dLum / 1.0;
					rgbaThis.dRgba[SL2_PC_A] = _bNorm ? StdIntComponentTo64F_Norm<_uABits, _uAShift, _bSigned, false>( (*pui64Src), 1.0 ) : StdIntComponentTo64F<_uABits, _uAShift, _bSigned>( (*pui64Src), 1.0 );
				}
			}
		}
		return true;
	}

	/**
	 * Generic RGBA64F -> luminance/alpha format conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA64F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uLBits, unsigned _uABits,
		unsigned _uLShift, unsigned _uAShift,
		unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
	bool CFormat::LumAlphaFromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		const uint64_t ui64SrcRowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = SL2_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const SL2_RGBA64F & rgbaThis = reinterpret_cast<const SL2_RGBA64F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(SL2_RGBA64F)]);
					uint64_t * pui64Dst = reinterpret_cast<uint64_t *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize]);
					
					if ( _bNorm ) {
						/*double dLum = rgbaThis.dRgba[SL2_PC_R] * SL2_R_WEIGHT +
							rgbaThis.dRgba[SL2_PC_G] * SL2_G_WEIGHT +
							rgbaThis.dRgba[SL2_PC_B] * SL2_B_WEIGHT;*/
						// Values specified by OpenGL for luminance conversion: SL2_LS_CIE_1931 (0.3086f 0.6094f 0.082f)
						// https://www.opengl.org/archives/resources/code/samples/advanced/advanced97/notes/node140.html
						// But the user gets to select the luminance factors.
						double dLum = rgbaThis.dRgba[SL2_PC_R] * m_lLumaCoeffs[m_lsCurStandard].dRgb[0] +
							rgbaThis.dRgba[SL2_PC_G] * m_lLumaCoeffs[m_lsCurStandard].dRgb[1] +
							rgbaThis.dRgba[SL2_PC_B] * m_lLumaCoeffs[m_lsCurStandard].dRgb[2];
						Std64FToIntComponent_Norm<_uLBits, _uLShift, _bSigned, _bSrgb>( dLum, (*pui64Dst) );

						Std64FToIntComponent_Norm<_uABits, _uAShift, _bSigned, false>( rgbaThis.dRgba[SL2_PC_A], (*pui64Dst) );
					}
					else {
						// For integer formats, L is just a copy of R.
						// https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_integer.txt
						double dLum = rgbaThis.dRgba[SL2_PC_R];
						Std64FToIntComponent<_uLBits, _uLShift, _bSigned>( dLum, (*pui64Dst) );

						Std64FToIntComponent<_uABits, _uAShift, _bSigned>( rgbaThis.dRgba[SL2_PC_A], (*pui64Dst) );
					}
				}
			}
		}
		return true;
	}

	/**
	 * Luminance/alpha (floating-point) format -> RGBA64F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA64F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uLBits, unsigned _uABits,
		unsigned _uLShift, unsigned _uAShift,
		unsigned _uTexelSize>
	bool CFormat::LumAlphaFToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		const uint64_t ui64RowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = SL2_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					SL2_RGBA64F & rgbaThis = reinterpret_cast<SL2_RGBA64F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(SL2_RGBA64F)]);
					double dLum = 0.0;
					double dAlpha = 1.0;
					if constexpr ( _uLBits == 16 ) {
						const CFloat16 * pf16Src = reinterpret_cast<const CFloat16 *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize+(_uLShift>>3)]);
						dLum = static_cast<double>(*pf16Src);
					}
					else if constexpr ( _uLBits == 32 ) {
						const float * pf32Src = reinterpret_cast<const float *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize+(_uLShift>>3)]);
						dLum = (*pf32Src);
					}
					if constexpr ( _uABits == 16 ) {
						const CFloat16 * pf16Src = reinterpret_cast<const CFloat16 *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize+(_uAShift>>3)]);
						dAlpha = static_cast<double>(*pf16Src);
					}
					else if constexpr ( _uABits == 32 ) {
						const float * pf32Src = reinterpret_cast<const float *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize+(_uAShift>>3)]);
						dAlpha = (*pf32Src);
					}
					
					rgbaThis.dRgba[SL2_PC_R] = dLum / 1.0;
					rgbaThis.dRgba[SL2_PC_G] = dLum / 1.0;
					rgbaThis.dRgba[SL2_PC_B] = dLum / 1.0;
					rgbaThis.dRgba[SL2_PC_A] = dAlpha;
				}
			}
		}
		return true;
	}

	/**
	 * Generic RGBA64F -> luminance/alpha (floating-point) format conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA64F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uLBits, unsigned _uABits,
		unsigned _uLShift, unsigned _uAShift,
		unsigned _uTexelSize>
	bool CFormat::LumAlphaFFromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		const uint64_t ui64SrcRowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = SL2_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const SL2_RGBA64F & rgbaThis = reinterpret_cast<const SL2_RGBA64F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(SL2_RGBA64F)]);

					/*double dLum = rgbaThis.dRgba[SL2_PC_R] * SL2_R_WEIGHT +
						rgbaThis.dRgba[SL2_PC_G] * SL2_G_WEIGHT +
						rgbaThis.dRgba[SL2_PC_B] * SL2_B_WEIGHT;*/
					// Values specified by OpenGL for luminance conversion: SL2_LS_CIE_1931 (0.3086f 0.6094f 0.082f)
					// https://www.opengl.org/archives/resources/code/samples/advanced/advanced97/notes/node140.html
					// But the user gets to select the luminance factors.
					double dLum = rgbaThis.dRgba[SL2_PC_R] * m_lLumaCoeffs[m_lsCurStandard].dRgb[0] +
						rgbaThis.dRgba[SL2_PC_G] * m_lLumaCoeffs[m_lsCurStandard].dRgb[1] +
						rgbaThis.dRgba[SL2_PC_B] * m_lLumaCoeffs[m_lsCurStandard].dRgb[2];
					
					if constexpr ( _uLBits == 16 ) {
						CFloat16 * pf16Dst = reinterpret_cast<CFloat16 *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize+(_uLShift/8)]);
						(*pf16Dst) = dLum;
					}
					else if constexpr ( _uLBits == 32 ) {
						float * pf32Dst = reinterpret_cast<float *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize+(_uLShift/8)]);
						(*pf32Dst) = static_cast<float>(dLum);
					}

					if constexpr ( _uABits == 16 ) {
						CFloat16 * pf16Dst = reinterpret_cast<CFloat16 *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize+(_uAShift/8)]);
						(*pf16Dst) = rgbaThis.dRgba[SL2_PC_A];
					}
					else if constexpr ( _uABits == 32 ) {
						float * pf32Dst = reinterpret_cast<float *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize+(_uAShift/8)]);
						(*pf32Dst) = static_cast<float>(rgbaThis.dRgba[SL2_PC_A]);
					}
				}
			}
		}
		return true;
	}

	/**
	 * Intensity format -> RGBA64F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA64F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uIBits,
		unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bFloat>
	bool CFormat::IntensityToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		const uint64_t ui64RowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = SL2_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					SL2_RGBA64F & rgbaThis = reinterpret_cast<SL2_RGBA64F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(SL2_RGBA64F)]);
					double dInt = 0.0;
					if constexpr ( _bFloat ) {
						if constexpr ( _uIBits == 16 ) {
							const CFloat16 * pf16Src = reinterpret_cast<const CFloat16 *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize]);
							dInt = static_cast<double>(*pf16Src);
						}
						else if constexpr ( _uIBits == 32 ) {
							const float * pf32Src = reinterpret_cast<const float *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize]);
							dInt = (*pf32Src);
						}
					}
					else {
						const uint64_t * pui64Src = reinterpret_cast<const uint64_t *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize]);
						dInt = _bNorm ? StdIntComponentTo64F_Norm<_uIBits, 0, _bSigned, false>( (*pui64Src), 0.0 ) : StdIntComponentTo64F<_uIBits, 0, _bSigned>( (*pui64Src), 0.0 );
					}
					rgbaThis.dRgba[SL2_PC_R] = dInt;
					rgbaThis.dRgba[SL2_PC_G] = dInt;
					rgbaThis.dRgba[SL2_PC_B] = dInt;
					rgbaThis.dRgba[SL2_PC_A] = dInt;
				}
			}
		}
		return true;
	}

	/**
	 * Generic RGBA64F -> intensity format conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA64F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uIBits,
		unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bFloat>
	bool CFormat::IntensityFromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		const uint64_t ui64SrcRowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = SL2_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const SL2_RGBA64F & rgbaThis = reinterpret_cast<const SL2_RGBA64F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(SL2_RGBA64F)]);
					double dInt = (rgbaThis.dRgba[SL2_PC_R] * m_lLumaCoeffs[m_lsCurStandard].dRgb[0] +
						rgbaThis.dRgba[SL2_PC_G] * m_lLumaCoeffs[m_lsCurStandard].dRgb[1] +
						rgbaThis.dRgba[SL2_PC_B] * m_lLumaCoeffs[m_lsCurStandard].dRgb[2]) * rgbaThis.dRgba[SL2_PC_A];

					if constexpr ( _bFloat ) {
						if constexpr ( _uIBits == 16 ) {
							CFloat16 * pf16Dst = reinterpret_cast<CFloat16 *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize]);
							(*pf16Dst) = dInt;
						}
						else if constexpr ( _uIBits == 32 ) {
							float * pf32Dst = reinterpret_cast<float *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize]);
							(*pf32Dst) = static_cast<float>(dInt);
						}
					}
					else {
						uint64_t * pui64Dst = reinterpret_cast<uint64_t *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize]);
					
						if constexpr ( _bNorm ) {
							Std64FToIntComponent_Norm<_uIBits, 0, _bSigned, false>( dInt, (*pui64Dst) );
						}
						else {
							Std64FToIntComponent<_uIBits, 0, _bSigned>( dInt, (*pui64Dst) );
						}
					}
				}
			}
		}
		return true;
	}

	/**
	 * Stencil-X -> RGBA64F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA64F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template<typename _tType, unsigned _uBits>
	bool CFormat::StencilXToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		const uint64_t ui64RowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = SL2_ROUND_UP( sizeof( _tType ) * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const double dNormFactor = (1 << _uBits) - 1.0;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					SL2_RGBA64F & rgbaThis = reinterpret_cast<SL2_RGBA64F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(SL2_RGBA64F)]);
					const _tType * prSrc = reinterpret_cast<const _tType *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(_tType)]);
					rgbaThis.dRgba[SL2_PC_R] = 0.0;
					rgbaThis.dRgba[SL2_PC_G] = 0.0;
					rgbaThis.dRgba[SL2_PC_B] = 0.0;
					rgbaThis.dRgba[SL2_PC_A] = (*prSrc) / dNormFactor;
				}
			}
		}
		return true;
	}

	/**
	 * RGBA64F -> Stencil-X conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA64F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template<typename _tType, unsigned _uBits>
	bool CFormat::StencilXFromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * /*_pvParms*/ ) {
		const uint64_t ui64SrcRowSize = sizeof( SL2_RGBA64F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = SL2_ROUND_UP( sizeof( _tType ) * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const double dNormFactor = (1 << _uBits) - 0.5;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const SL2_RGBA64F & rgbaThis = reinterpret_cast<const SL2_RGBA64F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(SL2_RGBA64F)]);
					_tType * prDst = reinterpret_cast<_tType *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(_tType)]);
					
					(*prDst) = static_cast<_tType>(rgbaThis.dRgba[SL2_PC_A] * dNormFactor);
				}
			}
		}
		return true;
	}

	/**
	 * Returns the total size of a compressed image given a factor and its width and height.
	 *
	 * \param _ui32Width Width in pixels.
	 * \param _ui32Height Height in pixels.
	 * \param _ui32Depth Unused.
	 * \param _ui32Factor Multiplier.
	 * \param _pvParms Unused.
	 * \return Returns the size of the compressed data.
	 */
	inline uint32_t CFormat::GetCompressedSizeBc( uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, uint32_t _ui32Factor, const void * /*_pvParms*/ ) {
		return ((((_ui32Width + 3) >> 2) * ((_ui32Height + 3) >> 2) * _ui32Factor) >> 3) * _ui32Depth;
	}

	/**
	 * DXT1 -> RGBA64F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA64F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _bSrgb>
	bool CFormat::Dxt1ToRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms ) {
		struct SL2_DXT1_BLOCK {
			uint64_t ui64Rgb;
		};
		const SL2_DXT1_BLOCK * pbbBlocks = reinterpret_cast<const SL2_DXT1_BLOCK *>(_pui8Src);
		uint32_t ui32BlocksW = (_ui32Width + 3) / 4;
		uint32_t ui32BlocksH = (_ui32Height + 3) / 4;
		uint32_t ui32SliceSize = ui32BlocksW * ui32BlocksH * sizeof( SL2_DXT1_BLOCK );

		uint32_t ui32DstSliceSize = _ui32Width * _ui32Height;
		SL2_RGBA64F * prgbaTexels = reinterpret_cast<SL2_RGBA64F *>(_pui8Dst);
		SL2_RGBA64F dPaletteRgb[4];
		uint8_t ui8IndicesRgb[16];
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < ui32BlocksH; ++Y ) {
				for ( uint32_t X = 0; X < ui32BlocksW; ++X ) {
					uint64_t ui64ThisBlock = pbbBlocks[Z*ui32SliceSize+Y*ui32BlocksW+X].ui64Rgb;
					DecodeDXT1<_bSrgb>( ui64ThisBlock, dPaletteRgb );
					Dxt1Indices( ui64ThisBlock, ui8IndicesRgb );

					for ( uint32_t I = 0; I < 16; ++I ) {
						uint32_t ui32ThisX = X * 4 + I % 4;
						uint32_t ui32ThisY = Y * 4 + I / 4;
						if ( ui32ThisX < _ui32Width && ui32ThisY < _ui32Height ) {
							SL2_RGBA64F * prgbaRow0 = &prgbaTexels[Z*ui32DstSliceSize+ui32ThisY*_ui32Width+ui32ThisX];
							(*prgbaRow0).dRgba[SL2_PC_R] = dPaletteRgb[ui8IndicesRgb[I]].dRgba[SL2_PC_R];
							(*prgbaRow0).dRgba[SL2_PC_G] = dPaletteRgb[ui8IndicesRgb[I]].dRgba[SL2_PC_G];
							(*prgbaRow0).dRgba[SL2_PC_B] = dPaletteRgb[ui8IndicesRgb[I]].dRgba[SL2_PC_B];
							(*prgbaRow0).dRgba[SL2_PC_A] = dPaletteRgb[ui8IndicesRgb[I]].dRgba[SL2_PC_A];
						}
					}
				}
			}
		}
		return true;
	}

	/**
	 * Generic RGBA64F -> DXT1 conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA64F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _ui8DefaultAlphaThresh, unsigned _bSrgb>
	bool CFormat::Dxt1FromRgba64F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const void * _pvParms ) {
		const SL2_KTX_INTERNAL_FORMAT_DATA * pifdData = reinterpret_cast<const SL2_KTX_INTERNAL_FORMAT_DATA *>(_pvParms);
		SL2_DXT_OPTIONS doOptions;
		if ( pifdData->pvCustom ) {
			doOptions = (*reinterpret_cast<SL2_DXT_OPTIONS *>(pifdData->pvCustom));
		}
		else {
			doOptions.fAlphaThresh = _ui8DefaultAlphaThresh / 255.0f;
			doOptions.fRedWeight = static_cast<float>(m_lLumaCoeffs[m_lsCurStandard].dRgb[0]);
			doOptions.fGreenWeight = static_cast<float>(m_lLumaCoeffs[m_lsCurStandard].dRgb[1]);
			doOptions.fBlueWeight = static_cast<float>(m_lLumaCoeffs[m_lsCurStandard].dRgb[2]);
		}

		// Create X number of threads as we go along the blocks.
		/*LSH_THREAD tThreads[6];
		for ( uint32_t I = SL2_ELEMENTS( tThreads ); I--; ) {
			CThreadLib::MakeInvalidHandle( tThreads[I] );
		}*/
		std::unique_ptr<std::thread> tThreads[6];
		SL2_DXT_THREAD_DATA dtdData[SL2_ELEMENTS( tThreads )];
		for ( uint32_t I = SL2_ELEMENTS( dtdData ); I--; ) {
			dtdData[I].bDone = true;
			dtdData[I].pdoOptions = &doOptions;
			dtdData[I].pkifdFormatData = pifdData;
			dtdData[I].ui32SrcX = 0;
			dtdData[I].pui8Src = _pui8Src;
			dtdData[I].ui32Width = _ui32Width;
			dtdData[I].ui32Height = _ui32Height;
			dtdData[I].ui32Depth = _ui32Depth;
		}

		// Number of blocks along the width.
		uint32_t ui32Width = (_ui32Width + 3) >> 2;
		// Number of blocks along the height.
		uint32_t ui32TotalScanLines = (_ui32Height + 3) >> 2;
		// Size per slice.
		uint32_t ui32SliceSize = ui32Width * ui32TotalScanLines * sizeof( uint64_t );
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			uint8_t * pui8Dst = &_pui8Dst[Z*ui32SliceSize];
			for ( uint32_t Y = 0; Y < ui32TotalScanLines; Y += SL2_DXT_ROWS ) {					
				// Find a free thread.
				for ( size_t I = 0; I <= SL2_ELEMENTS( tThreads ); ++I ) {
					I %= SL2_ELEMENTS( tThreads );
					if ( dtdData[I].bDone ) {
						// Thread stopped or never started.
						//CThreadLib::CloseThread( tThreads[I] );
						tThreads[I].release();
						
						dtdData[I].bDone = false;
						
						dtdData[I].ui32SrcY = Y;
						dtdData[I].ui32SrcZ = Z;
						dtdData[I].pui8Dest = pui8Dst;
						//dtdData[I].pfFormat = SL2_PF_DXT1;
						try {
							tThreads[I] = std::make_unique<std::thread>( DxtThread<_bSrgb>, &dtdData[I] );
						}
						catch ( ... ) {
							for ( auto J = SL2_ELEMENTS( tThreads ); J--; ) {
								if ( tThreads[J] ) {
									while ( !dtdData[J].bDone ) { dtdData[J].eEvent.WaitForSignal( 10 ); }
									tThreads[J].release();
								}
							}
							return false;
						}
						/*if ( !CThreadLib::CreateThread( DxtThread<_bSrgb>, &dtdData[I], &tThreads[I] ) ) {
							
						}*/
						break;
					}
					//CStd::Sleep( 10 );
				}

				pui8Dst += DxtBlockSize( (*pifdData) ) * ui32Width * SL2_DXT_ROWS;
			}
		}

		for ( auto I = SL2_ELEMENTS( tThreads ); I--; ) {
			if ( tThreads[I] ) {
				while ( !dtdData[I].bDone ) { dtdData[I].eEvent.WaitForSignal( 10 ); }
				tThreads[I].release();
			}
		}
		return true;
	}

	/**
	 * Thread function for converting a block of texels to DXTn formats.
	 *
	 * \param _lpParameter The thread information, stored as a pointer to a SL2_DXT_THREAD_DATA structure.
	 * \return Returns 0.
	 */
	template <unsigned _bSrgb>
	uint32_t CFormat::DxtThread( void * _lpParameter ) {
		SL2_DXT_THREAD_DATA * pdtdData = static_cast<SL2_DXT_THREAD_DATA *>(_lpParameter);


		SL2_BLOCK bColors[4][4];
		uint32_t ui32Width = (pdtdData->ui32Width + 3) >> 2;
		// Number of blocks along the height.
		uint32_t ui32TotalScanLines = (pdtdData->ui32Height + 3) >> 2;

		uint32_t ui32SrcStride = CFormat::GetRowSize( SL2_VK_FORMAT_R64G64B64A64_SFLOAT, pdtdData->ui32Width );
		const uint8_t * pui8Src = pdtdData->pui8Src;
		pui8Src += (CFormat::GetFormatSize( SL2_VK_FORMAT_R64G64B64A64_SFLOAT, pdtdData->ui32Width, pdtdData->ui32Height, pdtdData->ui32SrcZ ));
		pui8Src += (ui32SrcStride << 2) * pdtdData->ui32SrcY;

		uint32_t ui32BlockSize = CFormat::DxtBlockSize( (*pdtdData->pkifdFormatData) );

		// Do SL2_DXT_ROWS rows at a time.
		uint32_t ui32Mask = 0;
		for ( uint32_t K = 0; K < SL2_DXT_ROWS; ++K ) {
			if ( pdtdData->ui32SrcY >= ui32TotalScanLines ) { break; }
			SL2_PREFETCH_LINE( pui8Src + (K + 1) * ui32SrcStride );

			for ( uint32_t X = pdtdData->ui32SrcX; X < ui32Width; ++X ) {
				uint32_t ui32SrcX = X << 4;							// 4 texels per block wide, 4 channels per texel.
				// Get the 4-by-4 block.
				//double fAlphaHigh = 0.0f, fAlphaLow = 1.0f;
				for ( uint32_t J = 0; J < 4; ++J ) {				// Down the block height.
					const double * pfThisRowStart = reinterpret_cast<const double *>(pui8Src + J * ui32SrcStride);
					if ( J + (pdtdData->ui32SrcY << 2) >= pdtdData->ui32Height ) {
						for ( uint32_t I = 0; I < 4; ++I ) {		// Along the block width.
							for ( uint32_t C = 0; C < 4; ++C ) {	// For each channel in this texel.
								bColors[J][I].dValues[C] = 0.0;
							}
						}
					}
					else {
						// The row is valid.
						for ( uint32_t I = 0; I < 4; ++I ) {		// Along the block width.
							// We are on a single texel now.  But it might be beyond the width of the image.
							if ( I + (X << 2) >= pdtdData->ui32Width ) {
								for ( uint32_t C = 0; C < 4; ++C ) {// For each channel in this texel.
									bColors[J][I].dValues[C] = 0.0;
								}
							}
							else {
								const double * pfSrcTexel = pfThisRowStart + ui32SrcX + (I << 2);
								// It is inside the image, so add it to an entry in the block.
								bColors[J][I].s.dR = pfSrcTexel[SL2_PC_R];
								bColors[J][I].s.dG = pfSrcTexel[SL2_PC_G];
								bColors[J][I].s.dB = pfSrcTexel[SL2_PC_B];
								bColors[J][I].s.dA = pfSrcTexel[SL2_PC_A];
								/*fAlphaHigh = CStd::Max<double>( fAlphaHigh, bColors[J][I].s.fA );
								fAlphaLow = CStd::Min<double>( fAlphaLow, bColors[J][I].s.fA );*/
								ui32Mask |= 1 << ((J << 2) + I);
							}
						}
					}
				}

				// The local block is filled.  Send it to the filter to determine the best high and low colors to use.
				int iFlags = squish::kColorMetricPerceptual | squish::kColorIterativeClusterFit | squish::kWeightColorByAlpha;
				
				squish::SquishConfig scConfig = {
					(*pdtdData->pdoOptions).fRedWeight,
					(*pdtdData->pdoOptions).fGreenWeight,
					(*pdtdData->pdoOptions).fBlueWeight,
					(*pdtdData->pdoOptions).fAlphaThresh,
				};
#ifdef SQUISH_USE_FLOATS
				double * pdBlock = bColors[0][0].dValues;
#else
				squish::u8 u8Block[4][4][4];
				for ( uint32_t Y = 0; Y < 4; ++Y ) {			// Block height.
					for ( uint32_t X = 0; X < 4; ++X ) {		// Block width.
						for ( uint32_t I = 0; I < 4; ++I ) {	// Colors.
							u8Block[Y][X][I] = static_cast<squish::u8>(bColors[Y][X].dValues[I] * 255.0);
						}
					}
				}
#endif	// #ifdef SQUISH_USE_FLOATS

#if 0
				switch ( pdtdData->pfFormat ) {
					case SL2_PF_DXT1 : {
						iFlags |= squish::kDxt1;
						break;
					}
					case SL2_PF_DXT2 : {
						// Premultiply the alpha in the block and fall through.
						for ( uint32_t G = 0; G < 4; ++G ) {
							for ( uint32_t H = 0; H < 4; ++H ) {
								double dAlpha = bColors[G][H].s.fA;
								bColors[G][H].s.fR *= dAlpha;
								bColors[G][H].s.fG *= dAlpha;
								bColors[G][H].s.fB *= dAlpha;
							}
						}
					}
					case SL2_PF_DXT3 : {
						iFlags |= squish::kDxt3;
						break;
					}
					case SL2_PF_DXT4 : {
						// Premultiply the alpha in the block and fall through.
						for ( uint32_t G = 0; G < 4; ++G ) {
							for ( uint32_t H = 0; H < 4; ++H ) {
								double dAlpha = bColors[G][H].s.fA;
								bColors[G][H].s.dR *= dAlpha;
								bColors[G][H].s.dG *= dAlpha;
								bColors[G][H].s.dB *= dAlpha;
							}
						}
					}
					case SL2_PF_DXT5 : {
						iFlags |= squish::kDxt5;
						break;
					}
					case SL2_PF_BC4S : {
						iFlags |= squish::kSigned;
						// Fall through.
					}
					case SL2_PF_BC4 : {
						iFlags |= squish::kBc4;
						if ( pdtdData->bLatc ) {
							// Only channel R is used for color, so update channel R with the combined weights of every RGB channel.
							for ( uint32_t G = 0; G < 4; ++G ) {
								for ( uint32_t H = 0; H < 4; ++H ) {
									bColors[G][H].s.fR = bColors[G][H].s.fR * pdtdData->pdoOptions->fRedWeight +
										bColors[G][H].s.fG * pdtdData->pdoOptions->fGreenWeight +
										bColors[G][H].s.fB * pdtdData->pdoOptions->fBlueWeight;
								}
							}
						}
						break;
					}
					case SL2_PF_BC5S : {
						iFlags |= squish::kSigned;
						// Fall through.
					}
					case SL2_PF_BC5 : {
						iFlags |= squish::kBc5;
						if ( pdtdData->bLatc ) {
							iFlags |= squish::kBc5IsLatc2;
							// Only channel R is used for color, so update channel R with the combined weights of every RGB channel.
							for ( uint32_t G = 0; G < 4; ++G ) {
								for ( uint32_t H = 0; H < 4; ++H ) {
									bColors[G][H].s.fR = bColors[G][H].s.fR * pdtdData->pdoOptions->fRedWeight +
										bColors[G][H].s.fG * pdtdData->pdoOptions->fGreenWeight +
										bColors[G][H].s.fB * pdtdData->pdoOptions->fBlueWeight;
								}
							}
						}
						break;
					}
					default : {}
				}
#endif// 0
				if ( _bSrgb != 0 ) {
					// Apply sRGB (importantly done after pre-multiply of alpha.
					for ( uint32_t G = 0; G < 4; ++G ) {
						for ( uint32_t H = 0; H < 4; ++H ) {
							bColors[G][H].s.dR = CUtilities::LinearToSRgb( bColors[G][H].s.dR );
							bColors[G][H].s.dG = CUtilities::LinearToSRgb( bColors[G][H].s.dG );
							bColors[G][H].s.dB = CUtilities::LinearToSRgb( bColors[G][H].s.dB );
						}
					}
				}
				squish::CompressMasked(
#ifdef SQUISH_USE_FLOATS
					pdBlock,
#else
					reinterpret_cast<squish::u8 *>(u8Block),
#endif	// #ifdef SQUISH_USE_FLOATS
					ui32Mask,
					pdtdData->pui8Dest, iFlags, scConfig );

				pdtdData->pui8Dest += ui32BlockSize;
			}
			pui8Src += (ui32SrcStride << 2);
			++pdtdData->ui32SrcY;
		}

		pdtdData->bDone = true;
		pdtdData->eEvent.Signal();
		return 0;
	}

}	// namespace sl2

#pragma warning( pop )
